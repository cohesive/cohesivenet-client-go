/*
VNS3 Controller API

Cohesive networks VNS3 provides complete control of your network's addressing, routes, rules and edge enabling a secure, connected and reactive cloud network. 

API version: 6.0.0
Contact: support@cohesive.net
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cohesivenet

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// AccessApiService AccessApi service
type AccessApiService service

type ApiCreateAccessURLRequest struct {
	ctx context.Context
	ApiService *AccessApiService
	createAccessUrlRequest *CreateAccessURLRequest
}

func (r ApiCreateAccessURLRequest) CreateAccessURLRequest(createAccessUrlRequest CreateAccessURLRequest) ApiCreateAccessURLRequest {
	r.createAccessUrlRequest = &createAccessUrlRequest
	return r
}

func (r ApiCreateAccessURLRequest) Execute() (*AccessUrlDetail, *http.Response, error) {
	return r.ApiService.CreateAccessUrl(r)
}

/*
CreateAccessUrl Create access Url

Create access Url

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAccessURLRequest
*/
func (api *AccessApiService) CreateAccessUrlRequest(ctx context.Context) ApiCreateAccessURLRequest {
	return ApiCreateAccessURLRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccessUrlDetail
func (api *AccessApiService) CreateAccessUrl(r ApiCreateAccessURLRequest) (*AccessUrlDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccessUrlDetail
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "AccessApiService.CreateAccessUrl")
	if err != nil {
		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/access/url"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAccessUrlRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 {
			var v ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateApiTokenRequest struct {
	ctx context.Context
	ApiService *AccessApiService
	createAPITokenRequest *CreateAPITokenRequest
}

func (r ApiCreateApiTokenRequest) CreateAPITokenRequest(createAPITokenRequest CreateAPITokenRequest) ApiCreateApiTokenRequest {
	r.createAPITokenRequest = &createAPITokenRequest
	return r
}

func (r ApiCreateApiTokenRequest) Execute() (*AccessTokenDetail, *http.Response, error) {
	return r.ApiService.CreateApiToken(r)
}

/*
CreateApiToken Create API token

Create api token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateApiTokenRequest
*/
func (api *AccessApiService) CreateApiTokenRequest(ctx context.Context) ApiCreateApiTokenRequest {
	return ApiCreateApiTokenRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccessTokenDetail
func (api *AccessApiService) CreateApiToken(r ApiCreateApiTokenRequest) (*AccessTokenDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccessTokenDetail
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "AccessApiService.CreateApiToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/access/token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAPITokenRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 {
			var v ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAccessUrlRequest struct {
	ctx context.Context
	ApiService *AccessApiService
	accessUrlId int32
}

func (r ApiDeleteAccessUrlRequest) Execute() (*SimpleStringResponse, *http.Response, error) {
	return r.ApiService.DeleteAccessUrl(r)
}

/*
DeleteAccessUrl Delete access Url

Delete access Url by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessUrlId Access Url ID
 @return ApiDeleteAccessUrlRequest
*/
func (api *AccessApiService) DeleteAccessUrlRequest(ctx context.Context, accessUrlId int32) ApiDeleteAccessUrlRequest {
	return ApiDeleteAccessUrlRequest{
		ApiService: api,
		ctx: ctx,
		accessUrlId: accessUrlId,
	}
}

// Execute executes the request
//  @return SimpleStringResponse
func (api *AccessApiService) DeleteAccessUrl(r ApiDeleteAccessUrlRequest) (*SimpleStringResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleStringResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "AccessApiService.DeleteAccessUrl")
	if err != nil {
		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/access/url/{access_url_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"access_url_id"+"}", url.PathEscape(parameterToString(r.accessUrlId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 {
			var v ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAccessUrlBySearchRequest struct {
	ctx context.Context
	ApiService *AccessApiService
	deleteAccessUrlRequest *DeleteAccessURLSearchRequest
}

func (r ApiDeleteAccessUrlBySearchRequest) DeleteAccessUrlRequest(deleteAccessUrlRequest DeleteAccessURLSearchRequest) ApiDeleteAccessUrlBySearchRequest {
	r.deleteAccessUrlRequest = &deleteAccessUrlRequest
	return r
}

func (r ApiDeleteAccessUrlBySearchRequest) Execute() (*SimpleStringResponse, *http.Response, error) {
	return r.ApiService.DeleteAccessUrlBySearch(r)
}

/*
DeleteAccessUrlBySearch Find and delete access Url

Delete access Url by ID or Url

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteAccessUrlBySearchRequest
*/
func (api *AccessApiService) DeleteAccessUrlBySearchRequest(ctx context.Context) ApiDeleteAccessUrlBySearchRequest {
	return ApiDeleteAccessUrlBySearchRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SimpleStringResponse
func (api *AccessApiService) DeleteAccessUrlBySearch(r ApiDeleteAccessUrlBySearchRequest) (*SimpleStringResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleStringResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "AccessApiService.DeleteAccessUrlBySearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/access/url"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteAccessUrlRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 {
			var v ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteApiTokenRequest struct {
	ctx context.Context
	ApiService *AccessApiService
	tokenId int32
}

func (r ApiDeleteApiTokenRequest) Execute() (*SimpleStringResponse, *http.Response, error) {
	return r.ApiService.DeleteApiToken(r)
}

/*
DeleteApiToken Delete API token

Delete API token by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tokenId Token ID
 @return ApiDeleteApiTokenRequest
*/
func (api *AccessApiService) DeleteApiTokenRequest(ctx context.Context, tokenId int32) ApiDeleteApiTokenRequest {
	return ApiDeleteApiTokenRequest{
		ApiService: api,
		ctx: ctx,
		tokenId: tokenId,
	}
}

// Execute executes the request
//  @return SimpleStringResponse
func (api *AccessApiService) DeleteApiToken(r ApiDeleteApiTokenRequest) (*SimpleStringResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleStringResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "AccessApiService.DeleteApiToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/access/token/{token_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"token_id"+"}", url.PathEscape(parameterToString(r.tokenId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 {
			var v ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccessUrlRequest struct {
	ctx context.Context
	ApiService *AccessApiService
	accessUrlId int32
}

func (r ApiGetAccessUrlRequest) Execute() (*AccessUrlDetail, *http.Response, error) {
	return r.ApiService.GetAccessUrl(r)
}

/*
GetAccessUrl Get access Url

Retrieve details for specific access url (including expired ones)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accessUrlId Access Url ID
 @return ApiGetAccessUrlRequest
*/
func (api *AccessApiService) GetAccessUrlRequest(ctx context.Context, accessUrlId int32) ApiGetAccessUrlRequest {
	return ApiGetAccessUrlRequest{
		ApiService: api,
		ctx: ctx,
		accessUrlId: accessUrlId,
	}
}

// Execute executes the request
//  @return AccessUrlDetail
func (api *AccessApiService) GetAccessUrl(r ApiGetAccessUrlRequest) (*AccessUrlDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccessUrlDetail
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "AccessApiService.GetAccessUrl")
	if err != nil {
		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/access/url/{access_url_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"access_url_id"+"}", url.PathEscape(parameterToString(r.accessUrlId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 {
			var v ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccessUrlsRequest struct {
	ctx context.Context
	ApiService *AccessApiService
}

func (r ApiGetAccessUrlsRequest) Execute() (*AccessUrlListResponse, *http.Response, error) {
	return r.ApiService.GetAccessUrls(r)
}

/*
GetAccessUrls Get access Urls

Retrieve list of users' access urls, including expired ones

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccessUrlsRequest
*/
func (api *AccessApiService) GetAccessUrlsRequest(ctx context.Context) ApiGetAccessUrlsRequest {
	return ApiGetAccessUrlsRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccessUrlListResponse
func (api *AccessApiService) GetAccessUrls(r ApiGetAccessUrlsRequest) (*AccessUrlListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccessUrlListResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "AccessApiService.GetAccessUrls")
	if err != nil {
		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/access/urls"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApiTokenRequest struct {
	ctx context.Context
	ApiService *AccessApiService
	tokenId int32
}

func (r ApiGetApiTokenRequest) Execute() (*AccessTokenDetail, *http.Response, error) {
	return r.ApiService.GetApiToken(r)
}

/*
GetApiToken Get API access token

Retrieve details for specific access token (including expired ones)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tokenId Token ID
 @return ApiGetApiTokenRequest
*/
func (api *AccessApiService) GetApiTokenRequest(ctx context.Context, tokenId int32) ApiGetApiTokenRequest {
	return ApiGetApiTokenRequest{
		ApiService: api,
		ctx: ctx,
		tokenId: tokenId,
	}
}

// Execute executes the request
//  @return AccessTokenDetail
func (api *AccessApiService) GetApiToken(r ApiGetApiTokenRequest) (*AccessTokenDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccessTokenDetail
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "AccessApiService.GetApiToken")
	if err != nil {
		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/access/token/{token_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"token_id"+"}", url.PathEscape(parameterToString(r.tokenId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 {
			var v ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApiTokensRequest struct {
	ctx context.Context
	ApiService *AccessApiService
}

func (r ApiGetApiTokensRequest) Execute() (*AccessTokenListResponse, *http.Response, error) {
	return r.ApiService.GetApiTokens(r)
}

/*
GetApiTokens Get API access tokens

Retrieve list of api tokens

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetApiTokensRequest
*/
func (api *AccessApiService) GetApiTokensRequest(ctx context.Context) ApiGetApiTokensRequest {
	return ApiGetApiTokensRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccessTokenListResponse
func (api *AccessApiService) GetApiTokens(r ApiGetApiTokensRequest) (*AccessTokenListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AccessTokenListResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "AccessApiService.GetApiTokens")
	if err != nil {
		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/access/tokens"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}


/*
TODO Identity API endpoints
*/

// type ApiGetIdentityControllerSettingsRequest struct {
// 	ctx context.Context
// 	ApiService *AccessApiService
// }

// func (r ApiGetIdentityControllerSettingsRequest) Execute() (*Object, *http.Response, error) {
// 	return r.ApiService.GetIdentityControllerSettings(r)
// }

// /*
// GetIdentityControllerSettings Get identity Settings for VPN Users

// get Identity VPN settings

//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @return ApiGetIdentityControllerSettingsRequest
// */
// func (api *AccessApiService) GetIdentityControllerSettingsRequest(ctx context.Context) ApiGetIdentityControllerSettingsRequest {
// 	return ApiGetIdentityControllerSettingsRequest{
// 		ApiService: api,
// 		ctx: ctx,
// 	}
// }

// // Execute executes the request
// //  @return Object
// func (api *AccessApiService) GetIdentityControllerSettings(r ApiGetIdentityControllerSettingsRequest) (*Object, *http.Response, error) {
// 	var (
// 		localVarHTTPMethod   = http.MethodGet
// 		localVarPostBody     interface{}
// 		formFiles            []formFile
// 		localVarReturnValue  *Object
// 	)

// 	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "AccessApiService.GetIdentityControllerSettings")
// 	if err != nil {
// 		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
// 	}

// 	localVarPath := localBasePath + "/identity/controller"

// 	localVarHeaderParams := make(map[string]string)
// 	localVarQueryParams := url.Values{}
// 	localVarFormParams := url.Values{}

// 	// to determine the Content-Type header
// 	localVarHTTPContentTypes := []string{}

// 	// set Content-Type header
// 	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
// 	if localVarHTTPContentType != "" {
// 		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
// 	}

// 	// to determine the Accept header
// 	localVarHTTPHeaderAccepts := []string{"application/json"}

// 	// set Accept header
// 	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
// 	if localVarHTTPHeaderAccept != "" {
// 		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
// 	}
// 	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
// 	if err != nil {
// 		return localVarReturnValue, nil, err
// 	}

// 	localVarHTTPResponse, err := api.client.callAPI(req)
// 	if err != nil || localVarHTTPResponse == nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
// 	localVarHTTPResponse.Body.Close()
// 	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
// 	if err != nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	if localVarHTTPResponse.StatusCode >= 300 {
// 		newErr := &GenericAPIError{
// 			body:  localVarBody,
// 			error: localVarHTTPResponse.Status,
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 	if err != nil {
// 		newErr := &GenericAPIError{
// 			body:  localVarBody,
// 			error: err.Error(),
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	return localVarReturnValue, localVarHTTPResponse, nil
// }

// type ApiGetIdentityVPNSettingsRequest struct {
// 	ctx context.Context
// 	ApiService *AccessApiService
// }

// func (r ApiGetIdentityVPNSettingsRequest) Execute() (*Object, *http.Response, error) {
// 	return r.ApiService.GetIdentityVPNSettings(r)
// }

// /*
// GetIdentityVPNSettings Get identity Settings for VPN Users

// get Identity VPN settings

//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @return ApiGetIdentityVPNSettingsRequest
// */
// func (api *AccessApiService) GetIdentityVPNSettingsRequest(ctx context.Context) ApiGetIdentityVPNSettingsRequest {
// 	return ApiGetIdentityVPNSettingsRequest{
// 		ApiService: api,
// 		ctx: ctx,
// 	}
// }

// // Execute executes the request
// //  @return Object
// func (api *AccessApiService) GetIdentityVPNSettings(r ApiGetIdentityVPNSettingsRequest) (*Object, *http.Response, error) {
// 	var (
// 		localVarHTTPMethod   = http.MethodGet
// 		localVarPostBody     interface{}
// 		formFiles            []formFile
// 		localVarReturnValue  *Object
// 	)

// 	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "AccessApiService.GetIdentityVPNSettings")
// 	if err != nil {
// 		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
// 	}

// 	localVarPath := localBasePath + "/identity/vpn"

// 	localVarHeaderParams := make(map[string]string)
// 	localVarQueryParams := url.Values{}
// 	localVarFormParams := url.Values{}

// 	// to determine the Content-Type header
// 	localVarHTTPContentTypes := []string{}

// 	// set Content-Type header
// 	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
// 	if localVarHTTPContentType != "" {
// 		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
// 	}

// 	// to determine the Accept header
// 	localVarHTTPHeaderAccepts := []string{"application/json"}

// 	// set Accept header
// 	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
// 	if localVarHTTPHeaderAccept != "" {
// 		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
// 	}
// 	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
// 	if err != nil {
// 		return localVarReturnValue, nil, err
// 	}

// 	localVarHTTPResponse, err := api.client.callAPI(req)
// 	if err != nil || localVarHTTPResponse == nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
// 	localVarHTTPResponse.Body.Close()
// 	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
// 	if err != nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	if localVarHTTPResponse.StatusCode >= 300 {
// 		newErr := &GenericAPIError{
// 			body:  localVarBody,
// 			error: localVarHTTPResponse.Status,
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 	if err != nil {
// 		newErr := &GenericAPIError{
// 			body:  localVarBody,
// 			error: err.Error(),
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	return localVarReturnValue, localVarHTTPResponse, nil
// }

// type ApiPostTestIdentityControllerSettingsRequest struct {
// 	ctx context.Context
// 	ApiService *AccessApiService
// 	postTestIdentityControllerSettingsRequest *PostTestIdentityControllerSettingsRequest
// }

// func (r ApiPostTestIdentityControllerSettingsRequest) PostTestIdentityControllerSettingsRequest(postTestIdentityControllerSettingsRequest PostTestIdentityControllerSettingsRequest) ApiPostTestIdentityControllerSettingsRequest {
// 	r.postTestIdentityControllerSettingsRequest = &postTestIdentityControllerSettingsRequest
// 	return r
// }

// func (r ApiPostTestIdentityControllerSettingsRequest) Execute() (*PostTestIdentityVPNSettings200Response, *http.Response, error) {
// 	return r.ApiService.PostTestIdentityControllerSettings(r)
// }

// /*
// PostTestIdentityControllerSettings Test Controller Identity Settings. Currently only LDAP testing is supported.

// Test Controller Identity settings

//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @return ApiPostTestIdentityControllerSettingsRequest
// */
// func (api *AccessApiService) PostTestIdentityControllerSettingsRequest(ctx context.Context) ApiPostTestIdentityControllerSettingsRequest {
// 	return ApiPostTestIdentityControllerSettingsRequest{
// 		ApiService: api,
// 		ctx: ctx,
// 	}
// }

// // Execute executes the request
// //  @return PostTestIdentityVPNSettings200Response
// func (api *AccessApiService) PostTestIdentityControllerSettings(r ApiPostTestIdentityControllerSettingsRequest) (*PostTestIdentityVPNSettings200Response, *http.Response, error) {
// 	var (
// 		localVarHTTPMethod   = http.MethodPost
// 		localVarPostBody     interface{}
// 		formFiles            []formFile
// 		localVarReturnValue  *PostTestIdentityVPNSettings200Response
// 	)

// 	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "AccessApiService.PostTestIdentityControllerSettings")
// 	if err != nil {
// 		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
// 	}

// 	localVarPath := localBasePath + "/identity/controller/test"

// 	localVarHeaderParams := make(map[string]string)
// 	localVarQueryParams := url.Values{}
// 	localVarFormParams := url.Values{}

// 	// to determine the Content-Type header
// 	localVarHTTPContentTypes := []string{"application/json"}

// 	// set Content-Type header
// 	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
// 	if localVarHTTPContentType != "" {
// 		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
// 	}

// 	// to determine the Accept header
// 	localVarHTTPHeaderAccepts := []string{"application/json"}

// 	// set Accept header
// 	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
// 	if localVarHTTPHeaderAccept != "" {
// 		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
// 	}
// 	// body params
// 	localVarPostBody = r.postTestIdentityControllerSettingsRequest
// 	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
// 	if err != nil {
// 		return localVarReturnValue, nil, err
// 	}

// 	localVarHTTPResponse, err := api.client.callAPI(req)
// 	if err != nil || localVarHTTPResponse == nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
// 	localVarHTTPResponse.Body.Close()
// 	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
// 	if err != nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	if localVarHTTPResponse.StatusCode >= 300 {
// 		newErr := &GenericAPIError{
// 			body:  localVarBody,
// 			error: localVarHTTPResponse.Status,
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 	if err != nil {
// 		newErr := &GenericAPIError{
// 			body:  localVarBody,
// 			error: err.Error(),
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	return localVarReturnValue, localVarHTTPResponse, nil
// }

// type ApiPostTestIdentityVPNSettingsRequest struct {
// 	ctx context.Context
// 	ApiService *AccessApiService
// 	postTestLdapSettingsRequest *PostTestLdapSettingsRequest
// }

// func (r ApiPostTestIdentityVPNSettingsRequest) PostTestLdapSettingsRequest(postTestLdapSettingsRequest PostTestLdapSettingsRequest) ApiPostTestIdentityVPNSettingsRequest {
// 	r.postTestLdapSettingsRequest = &postTestLdapSettingsRequest
// 	return r
// }

// func (r ApiPostTestIdentityVPNSettingsRequest) Execute() (*PostTestIdentityVPNSettings200Response, *http.Response, error) {
// 	return r.ApiService.PostTestIdentityVPNSettings(r)
// }

// /*
// PostTestIdentityVPNSettings Test VPN Identity Settings

// Test VPN Identity settings

//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @return ApiPostTestIdentityVPNSettingsRequest
// */
// func (api *AccessApiService) PostTestIdentityVPNSettingsRequest(ctx context.Context) ApiPostTestIdentityVPNSettingsRequest {
// 	return ApiPostTestIdentityVPNSettingsRequest{
// 		ApiService: api,
// 		ctx: ctx,
// 	}
// }

// // Execute executes the request
// //  @return PostTestIdentityVPNSettings200Response
// func (api *AccessApiService) PostTestIdentityVPNSettings(r ApiPostTestIdentityVPNSettingsRequest) (*PostTestIdentityVPNSettings200Response, *http.Response, error) {
// 	var (
// 		localVarHTTPMethod   = http.MethodPost
// 		localVarPostBody     interface{}
// 		formFiles            []formFile
// 		localVarReturnValue  *PostTestIdentityVPNSettings200Response
// 	)

// 	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "AccessApiService.PostTestIdentityVPNSettings")
// 	if err != nil {
// 		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
// 	}

// 	localVarPath := localBasePath + "/identity/vpn/test"

// 	localVarHeaderParams := make(map[string]string)
// 	localVarQueryParams := url.Values{}
// 	localVarFormParams := url.Values{}

// 	// to determine the Content-Type header
// 	localVarHTTPContentTypes := []string{"application/json"}

// 	// set Content-Type header
// 	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
// 	if localVarHTTPContentType != "" {
// 		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
// 	}

// 	// to determine the Accept header
// 	localVarHTTPHeaderAccepts := []string{"application/json"}

// 	// set Accept header
// 	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
// 	if localVarHTTPHeaderAccept != "" {
// 		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
// 	}
// 	// body params
// 	localVarPostBody = r.postTestLdapSettingsRequest
// 	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
// 	if err != nil {
// 		return localVarReturnValue, nil, err
// 	}

// 	localVarHTTPResponse, err := api.client.callAPI(req)
// 	if err != nil || localVarHTTPResponse == nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
// 	localVarHTTPResponse.Body.Close()
// 	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
// 	if err != nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	if localVarHTTPResponse.StatusCode >= 300 {
// 		newErr := &GenericAPIError{
// 			body:  localVarBody,
// 			error: localVarHTTPResponse.Status,
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 	if err != nil {
// 		newErr := &GenericAPIError{
// 			body:  localVarBody,
// 			error: err.Error(),
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	return localVarReturnValue, localVarHTTPResponse, nil
// }

// type ApiPutExpireAccessUrlRequest struct {
// 	ctx context.Context
// 	ApiService *AccessApiService
// 	accessUrlId int32
// 	expireRequest *ExpireRequest
// }

// func (r ApiPutExpireAccessUrlRequest) ExpireRequest(expireRequest ExpireRequest) ApiPutExpireAccessUrlRequest {
// 	r.expireRequest = &expireRequest
// 	return r
// }

// func (r ApiPutExpireAccessUrlRequest) Execute() (*Object, *http.Response, error) {
// 	return r.ApiService.PutExpireAccessUrl(r)
// }

// /*
// PutExpireAccessUrl Expire access Url

// Expire access Url

//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @param accessUrlId Access Url ID
//  @return ApiPutExpireAccessUrlRequest
// */
// func (api *AccessApiService) PutExpireAccessUrlRequest(ctx context.Context, accessUrlId int32) ApiPutExpireAccessUrlRequest {
// 	return ApiPutExpireAccessUrlRequest{
// 		ApiService: api,
// 		ctx: ctx,
// 		accessUrlId: accessUrlId,
// 	}
// }

// // Execute executes the request
// //  @return Object
// func (api *AccessApiService) PutExpireAccessUrl(r ApiPutExpireAccessUrlRequest) (*Object, *http.Response, error) {
// 	var (
// 		localVarHTTPMethod   = http.MethodPut
// 		localVarPostBody     interface{}
// 		formFiles            []formFile
// 		localVarReturnValue  *Object
// 	)

// 	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "AccessApiService.PutExpireAccessUrl")
// 	if err != nil {
// 		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
// 	}

// 	localVarPath := localBasePath + "/access/url/{access_url_id}"
// 	localVarPath = strings.Replace(localVarPath, "{"+"access_url_id"+"}", url.PathEscape(parameterToString(r.accessUrlId, "")), -1)

// 	localVarHeaderParams := make(map[string]string)
// 	localVarQueryParams := url.Values{}
// 	localVarFormParams := url.Values{}

// 	// to determine the Content-Type header
// 	localVarHTTPContentTypes := []string{"application/json"}

// 	// set Content-Type header
// 	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
// 	if localVarHTTPContentType != "" {
// 		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
// 	}

// 	// to determine the Accept header
// 	localVarHTTPHeaderAccepts := []string{"application/json"}

// 	// set Accept header
// 	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
// 	if localVarHTTPHeaderAccept != "" {
// 		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
// 	}
// 	// body params
// 	localVarPostBody = r.expireRequest
// 	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
// 	if err != nil {
// 		return localVarReturnValue, nil, err
// 	}

// 	localVarHTTPResponse, err := api.client.callAPI(req)
// 	if err != nil || localVarHTTPResponse == nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
// 	localVarHTTPResponse.Body.Close()
// 	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
// 	if err != nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	if localVarHTTPResponse.StatusCode >= 300 {
// 		newErr := &GenericAPIError{
// 			body:  localVarBody,
// 			error: localVarHTTPResponse.Status,
// 		}
// 		if localVarHTTPResponse.StatusCode >= 400 {
// 			var v ErrorResponse
// 			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 			newErr.model = v
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 	if err != nil {
// 		newErr := &GenericAPIError{
// 			body:  localVarBody,
// 			error: err.Error(),
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	return localVarReturnValue, localVarHTTPResponse, nil
// }

// type ApiPutExpireApiTokenRequest struct {
// 	ctx context.Context
// 	ApiService *AccessApiService
// 	tokenId int32
// 	expireRequest *ExpireRequest
// }

// func (r ApiPutExpireApiTokenRequest) ExpireRequest(expireRequest ExpireRequest) ApiPutExpireApiTokenRequest {
// 	r.expireRequest = &expireRequest
// 	return r
// }

// func (r ApiPutExpireApiTokenRequest) Execute() (*Object, *http.Response, error) {
// 	return r.ApiService.PutExpireApiToken(r)
// }

// /*
// PutExpireApiToken Expire API token

// Expire API token

//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @param tokenId Token ID
//  @return ApiPutExpireApiTokenRequest
// */
// func (api *AccessApiService) PutExpireApiTokenRequest(ctx context.Context, tokenId int32) ApiPutExpireApiTokenRequest {
// 	return ApiPutExpireApiTokenRequest{
// 		ApiService: api,
// 		ctx: ctx,
// 		tokenId: tokenId,
// 	}
// }

// // Execute executes the request
// //  @return Object
// func (api *AccessApiService) PutExpireApiToken(r ApiPutExpireApiTokenRequest) (*Object, *http.Response, error) {
// 	var (
// 		localVarHTTPMethod   = http.MethodPut
// 		localVarPostBody     interface{}
// 		formFiles            []formFile
// 		localVarReturnValue  *Object
// 	)

// 	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "AccessApiService.PutExpireApiToken")
// 	if err != nil {
// 		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
// 	}

// 	localVarPath := localBasePath + "/access/token/{token_id}"
// 	localVarPath = strings.Replace(localVarPath, "{"+"token_id"+"}", url.PathEscape(parameterToString(r.tokenId, "")), -1)

// 	localVarHeaderParams := make(map[string]string)
// 	localVarQueryParams := url.Values{}
// 	localVarFormParams := url.Values{}

// 	// to determine the Content-Type header
// 	localVarHTTPContentTypes := []string{"application/json"}

// 	// set Content-Type header
// 	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
// 	if localVarHTTPContentType != "" {
// 		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
// 	}

// 	// to determine the Accept header
// 	localVarHTTPHeaderAccepts := []string{"application/json"}

// 	// set Accept header
// 	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
// 	if localVarHTTPHeaderAccept != "" {
// 		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
// 	}
// 	// body params
// 	localVarPostBody = r.expireRequest
// 	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
// 	if err != nil {
// 		return localVarReturnValue, nil, err
// 	}

// 	localVarHTTPResponse, err := api.client.callAPI(req)
// 	if err != nil || localVarHTTPResponse == nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
// 	localVarHTTPResponse.Body.Close()
// 	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
// 	if err != nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	if localVarHTTPResponse.StatusCode >= 300 {
// 		newErr := &GenericAPIError{
// 			body:  localVarBody,
// 			error: localVarHTTPResponse.Status,
// 		}
// 		if localVarHTTPResponse.StatusCode >= 400 {
// 			var v ErrorResponse
// 			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 			newErr.model = v
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 	if err != nil {
// 		newErr := &GenericAPIError{
// 			body:  localVarBody,
// 			error: err.Error(),
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	return localVarReturnValue, localVarHTTPResponse, nil
// }

// type ApiPutIdentityControllerSettingsRequest struct {
// 	ctx context.Context
// 	ApiService *AccessApiService
// 	putIdentityControllerSettingsRequest *PutIdentityControllerSettingsRequest
// }

// func (r ApiPutIdentityControllerSettingsRequest) PutIdentityControllerSettingsRequest(putIdentityControllerSettingsRequest PutIdentityControllerSettingsRequest) ApiPutIdentityControllerSettingsRequest {
// 	r.putIdentityControllerSettingsRequest = &putIdentityControllerSettingsRequest
// 	return r
// }

// func (r ApiPutIdentityControllerSettingsRequest) Execute() (*IdentitySettingsResponse1, *http.Response, error) {
// 	return r.ApiService.PutIdentityControllerSettings(r)
// }

// /*
// PutIdentityControllerSettings Update Controller Identity settings

// Put Controller Identity settings

//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @return ApiPutIdentityControllerSettingsRequest
// */
// func (api *AccessApiService) PutIdentityControllerSettingsRequest(ctx context.Context) ApiPutIdentityControllerSettingsRequest {
// 	return ApiPutIdentityControllerSettingsRequest{
// 		ApiService: api,
// 		ctx: ctx,
// 	}
// }

// // Execute executes the request
// //  @return IdentitySettingsResponse1
// func (api *AccessApiService) PutIdentityControllerSettings(r ApiPutIdentityControllerSettingsRequest) (*IdentitySettingsResponse1, *http.Response, error) {
// 	var (
// 		localVarHTTPMethod   = http.MethodPut
// 		localVarPostBody     interface{}
// 		formFiles            []formFile
// 		localVarReturnValue  *IdentitySettingsResponse1
// 	)

// 	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "AccessApiService.PutIdentityControllerSettings")
// 	if err != nil {
// 		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
// 	}

// 	localVarPath := localBasePath + "/identity/controller"

// 	localVarHeaderParams := make(map[string]string)
// 	localVarQueryParams := url.Values{}
// 	localVarFormParams := url.Values{}

// 	// to determine the Content-Type header
// 	localVarHTTPContentTypes := []string{"application/json"}

// 	// set Content-Type header
// 	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
// 	if localVarHTTPContentType != "" {
// 		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
// 	}

// 	// to determine the Accept header
// 	localVarHTTPHeaderAccepts := []string{"application/json"}

// 	// set Accept header
// 	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
// 	if localVarHTTPHeaderAccept != "" {
// 		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
// 	}
// 	// body params
// 	localVarPostBody = r.putIdentityControllerSettingsRequest
// 	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
// 	if err != nil {
// 		return localVarReturnValue, nil, err
// 	}

// 	localVarHTTPResponse, err := api.client.callAPI(req)
// 	if err != nil || localVarHTTPResponse == nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
// 	localVarHTTPResponse.Body.Close()
// 	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
// 	if err != nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	if localVarHTTPResponse.StatusCode >= 300 {
// 		newErr := &GenericAPIError{
// 			body:  localVarBody,
// 			error: localVarHTTPResponse.Status,
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 	if err != nil {
// 		newErr := &GenericAPIError{
// 			body:  localVarBody,
// 			error: err.Error(),
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	return localVarReturnValue, localVarHTTPResponse, nil
// }

// type ApiPutIdentityVPNSettingsRequest struct {
// 	ctx context.Context
// 	ApiService *AccessApiService
// 	putIdentityVPNSettingsRequest *PutIdentityVPNSettingsRequest
// }

// func (r ApiPutIdentityVPNSettingsRequest) PutIdentityVPNSettingsRequest(putIdentityVPNSettingsRequest PutIdentityVPNSettingsRequest) ApiPutIdentityVPNSettingsRequest {
// 	r.putIdentityVPNSettingsRequest = &putIdentityVPNSettingsRequest
// 	return r
// }

// func (r ApiPutIdentityVPNSettingsRequest) Execute() (*IdentitySettingsResponse, *http.Response, error) {
// 	return r.ApiService.PutIdentityVPNSettings(r)
// }

// /*
// PutIdentityVPNSettings Update VPN Identity settings

// Put VPN Identity settings

//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @return ApiPutIdentityVPNSettingsRequest
// */
// func (api *AccessApiService) PutIdentityVPNSettingsRequest(ctx context.Context) ApiPutIdentityVPNSettingsRequest {
// 	return ApiPutIdentityVPNSettingsRequest{
// 		ApiService: api,
// 		ctx: ctx,
// 	}
// }

// // Execute executes the request
// //  @return IdentitySettingsResponse
// func (api *AccessApiService) PutIdentityVPNSettings(r ApiPutIdentityVPNSettingsRequest) (*IdentitySettingsResponse, *http.Response, error) {
// 	var (
// 		localVarHTTPMethod   = http.MethodPut
// 		localVarPostBody     interface{}
// 		formFiles            []formFile
// 		localVarReturnValue  *IdentitySettingsResponse
// 	)

// 	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "AccessApiService.PutIdentityVPNSettings")
// 	if err != nil {
// 		return localVarReturnValue, nil, &GenericAPIError{error: err.Error()}
// 	}

// 	localVarPath := localBasePath + "/identity/vpn"

// 	localVarHeaderParams := make(map[string]string)
// 	localVarQueryParams := url.Values{}
// 	localVarFormParams := url.Values{}

// 	// to determine the Content-Type header
// 	localVarHTTPContentTypes := []string{"application/json"}

// 	// set Content-Type header
// 	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
// 	if localVarHTTPContentType != "" {
// 		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
// 	}

// 	// to determine the Accept header
// 	localVarHTTPHeaderAccepts := []string{"application/json"}

// 	// set Accept header
// 	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
// 	if localVarHTTPHeaderAccept != "" {
// 		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
// 	}
// 	// body params
// 	localVarPostBody = r.putIdentityVPNSettingsRequest
// 	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
// 	if err != nil {
// 		return localVarReturnValue, nil, err
// 	}

// 	localVarHTTPResponse, err := api.client.callAPI(req)
// 	if err != nil || localVarHTTPResponse == nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
// 	localVarHTTPResponse.Body.Close()
// 	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
// 	if err != nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	if localVarHTTPResponse.StatusCode >= 300 {
// 		newErr := &GenericAPIError{
// 			body:  localVarBody,
// 			error: localVarHTTPResponse.Status,
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 	if err != nil {
// 		newErr := &GenericAPIError{
// 			body:  localVarBody,
// 			error: err.Error(),
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	return localVarReturnValue, localVarHTTPResponse, nil
// }
