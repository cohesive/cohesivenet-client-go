/*
VNS3 Controller API

Cohesive networks VNS3 provides complete control of your network's addressing, routes, rules and edge enabling a secure, connected and reactive cloud network. 

API version: 6.0.0
Contact: support@cohesive.net
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cohesivenet

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	m "cohesivenet/models"
)


// FirewallApiService FirewallApi service
type FirewallApiService service

type ApiCreateFwsetEntryRequest struct {
	ctx context.Context
	ApiService *FirewallApiService
	name string
	addEntryRequest *m.CreateFirewallEntryRequest
}

func (r ApiCreateFwsetEntryRequest) CreateFirewallEntryRequest(createFirewallEntryRequest m.CreateFirewallEntryRequest) ApiCreateFwsetEntryRequest {
	r.addEntryRequest = &createFirewallEntryRequest
	return r
}

func (r ApiCreateFwsetEntryRequest) Execute() (*m.FirewallFwsetDetailResponse, *http.Response, error) {
	return r.ApiService.AddEntryToFwsetExecute(r)
}

/*
AddEntryToFwset V2 Add entry to firewall fwset

Add entry to fwset

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name unique fwset name
 @return ApiCreateFwsetEntryRequest
*/
func (api *FirewallApiService) AddEntryToFwset(ctx context.Context, name string) ApiCreateFwsetEntryRequest {
	return ApiCreateFwsetEntryRequest{
		ApiService: api,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return m.FirewallFwsetDetailResponse
func (api *FirewallApiService) AddEntryToFwsetExecute(r ApiCreateFwsetEntryRequest) (*m.FirewallFwsetDetailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.FirewallFwsetDetailResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.AddEntryToFwset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/firewall/fwsets/{name}/entries"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addEntryRequest == nil {
		return localVarReturnValue, nil, reportError("addEntryRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addEntryRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddRuleToGroupRequest struct {
	ctx context.Context
	ApiService *FirewallApiService
	name string
	addRuleToGroupRequest *m.AddFirewallRuleToGroupRequest
}

func (r ApiAddRuleToGroupRequest) AddFirewallRuleToGroupRequest(addRuleToGroupRequest m.AddFirewallRuleToGroupRequest) ApiAddRuleToGroupRequest {
	r.addRuleToGroupRequest = &addRuleToGroupRequest
	return r
}

func (r ApiAddRuleToGroupRequest) Execute() (*m.RuleGroupDetailResponse, *http.Response, error) {
	return r.ApiService.AddRuleToGroupExecute(r)
}

/*
AddRuleToGroup V2 Add rule to existing rule group

Add rule to group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name unique rule group name
 @return ApiAddRuleToGroupRequest
*/
func (api *FirewallApiService) AddRuleToGroup(ctx context.Context, name string) ApiAddRuleToGroupRequest {
	return ApiAddRuleToGroupRequest{
		ApiService: api,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return Object
func (api *FirewallApiService) AddRuleToGroupExecute(r ApiAddRuleToGroupRequest) (*m.RuleGroupDetailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.RuleGroupDetailResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.AddRuleToGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/firewall/rules-groups/{name}/rules"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addRuleToGroupRequest == nil {
		return localVarReturnValue, nil, reportError("addRuleToGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addRuleToGroupRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddRuleToSubtableRequest struct {
	ctx context.Context
	ApiService *FirewallApiService
	name string
	addFirewallRuleToSubtableRequest *m.AddFirewallRuleToSubtableRequest
}

func (r ApiAddRuleToSubtableRequest) AddFirewallRuleToSubtableRequest(addFirewallRuleToSubtableRequest m.AddFirewallRuleToSubtableRequest) ApiAddRuleToSubtableRequest {
	r.addFirewallRuleToSubtableRequest = &addFirewallRuleToSubtableRequest
	return r
}

func (r ApiAddRuleToSubtableRequest) Execute() (*m.FirewallSubtableDetailResponse, *http.Response, error) {
	return r.ApiService.AddRuleToSubtableExecute(r)
}

/*
AddRuleToSubtable V2 Add rule to firewall subtable

Add rule to subtable

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name unique subtable name
 @return ApiAddRuleToSubtableRequest
*/
func (api *FirewallApiService) AddRuleToSubtable(ctx context.Context, name string) ApiAddRuleToSubtableRequest {
	return ApiAddRuleToSubtableRequest{
		ApiService: api,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return m.FirewallSubtableDetailResponse
func (api *FirewallApiService) AddRuleToSubtableExecute(r ApiAddRuleToSubtableRequest) (*m.FirewallSubtableDetailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.FirewallSubtableDetailResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.AddRuleToSubtable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/firewall/subtables/{name}/rules"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addFirewallRuleToSubtableRequest == nil {
		return localVarReturnValue, nil, reportError("addFirewallRuleToSubtableRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addFirewallRuleToSubtableRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteEntryFromFwsetRequest struct {
	ctx context.Context
	ApiService *FirewallApiService
	name string
	deleteFirewallEntryRequest *m.DeleteFirewallEntryRequest
}

func (r ApiDeleteEntryFromFwsetRequest) DeleteFirewallEntryRequest(deleteFirewallEntryRequest m.DeleteFirewallEntryRequest) ApiDeleteEntryFromFwsetRequest {
	r.deleteFirewallEntryRequest = &deleteFirewallEntryRequest
	return r
}

func (r ApiDeleteEntryFromFwsetRequest) Execute() (*m.FirewallFwsetDetailResponse, *http.Response, error) {
	return r.ApiService.DeleteEntryFromFwsetExecute(r)
}

/*
DeleteEntryFromFwset V2 Delete entry from firewall fwset

Remove entry from fwset

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name unique fwset name
 @return ApiDeleteEntryFromFwsetRequest
*/
func (api *FirewallApiService) DeleteEntryFromFwset(ctx context.Context, name string) ApiDeleteEntryFromFwsetRequest {
	return ApiDeleteEntryFromFwsetRequest{
		ApiService: api,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return m.FirewallFwsetDetailResponse
func (api *FirewallApiService) DeleteEntryFromFwsetExecute(r ApiDeleteEntryFromFwsetRequest) (*m.FirewallFwsetDetailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.FirewallFwsetDetailResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.DeleteEntryFromFwset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/firewall/fwsets/{name}/entries"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.deleteFirewallEntryRequest == nil {
		return localVarReturnValue, nil, reportError("deleteFirewallEntryRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deleteFirewallEntryRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteFirewallFwsetRequest struct {
	ctx context.Context
	ApiService *FirewallApiService
	name string
	force *bool
}

// Force delete if fwset is associated with rules or other fwsets
func (r ApiDeleteFirewallFwsetRequest) Force(force bool) ApiDeleteFirewallFwsetRequest {
	r.force = &force
	return r
}

func (r ApiDeleteFirewallFwsetRequest) Execute() (*m.FirewallFwsetDetailResponse, *http.Response, error) {
	return r.ApiService.DeleteFirewallFwsetExecute(r)
}

/*
DeleteFirewallFwset V2 Delete firewall fwset

Delete firewall fwset

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name unique fwset name
 @return ApiDeleteFirewallFwsetRequest
*/
func (api *FirewallApiService) DeleteFirewallFwset(ctx context.Context, name string) ApiDeleteFirewallFwsetRequest {
	return ApiDeleteFirewallFwsetRequest{
		ApiService: api,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return m.FirewallFwsetDetailResponse
func (api *FirewallApiService) DeleteFirewallFwsetExecute(r ApiDeleteFirewallFwsetRequest) (*m.FirewallFwsetDetailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.FirewallFwsetDetailResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.DeleteFirewallFwset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/firewall/fwsets/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteFirewallRuleRequest struct {
	ctx context.Context
	ApiService *FirewallApiService
	id string
}

func (r ApiDeleteFirewallRuleRequest) Execute() (*m.FirewallRuleDetailResponse, *http.Response, error) {
	return r.ApiService.DeleteFirewallRuleExecute(r)
}

/*
DeleteFirewallRule V2 delete firewall rule

Delete firewall rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Rule ID
 @return ApiDeleteFirewallRuleRequest
*/
func (api *FirewallApiService) DeleteFirewallRule(ctx context.Context, id string) ApiDeleteFirewallRuleRequest {
	return ApiDeleteFirewallRuleRequest{
		ApiService: api,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return m.FirewallRuleDetailResponse
func (api *FirewallApiService) DeleteFirewallRuleExecute(r ApiDeleteFirewallRuleRequest) (*m.FirewallRuleDetailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.FirewallRuleDetailResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.DeleteFirewallRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/firewall/rules/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteFirewallRuleGroupRequest struct {
	ctx context.Context
	ApiService *FirewallApiService
	name string
	force *bool
}

// Force delete if rule group has rules associated
func (r ApiDeleteFirewallRuleGroupRequest) Force(force bool) ApiDeleteFirewallRuleGroupRequest {
	r.force = &force
	return r
}

func (r ApiDeleteFirewallRuleGroupRequest) Execute() (*m.RuleGroupDetailResponse, *http.Response, error) {
	return r.ApiService.DeleteFirewallRuleGroupExecute(r)
}

/*
DeleteFirewallRuleGroup V2 Delete firewall rule group

Delete firewall rule group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name unique rule group name
 @return ApiDeleteFirewallRuleGroupRequest
*/
func (api *FirewallApiService) DeleteFirewallRuleGroup(ctx context.Context, name string) ApiDeleteFirewallRuleGroupRequest {
	return ApiDeleteFirewallRuleGroupRequest{
		ApiService: api,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return m.RuleGroupDetailResponse
func (api *FirewallApiService) DeleteFirewallRuleGroupExecute(r ApiDeleteFirewallRuleGroupRequest) (*m.RuleGroupDetailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.RuleGroupDetailResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.DeleteFirewallRuleGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/firewall/rules-groups/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteFirewallSubtableRequest struct {
	ctx context.Context
	ApiService *FirewallApiService
	name string
	force *bool
}

// Force delete if subtable is associated with rules in main firewall policy
func (r ApiDeleteFirewallSubtableRequest) Force(force bool) ApiDeleteFirewallSubtableRequest {
	r.force = &force
	return r
}

func (r ApiDeleteFirewallSubtableRequest) Execute() (*m.FirewallSubtableDetailResponse, *http.Response, error) {
	return r.ApiService.DeleteFirewallSubtableExecute(r)
}

/*
DeleteFirewallSubtable V2 Delete firewall subtable

Delete firewall subtable

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name unique subtable name
 @return ApiDeleteFirewallSubtableRequest
*/
func (api *FirewallApiService) DeleteFirewallSubtable(ctx context.Context, name string) ApiDeleteFirewallSubtableRequest {
	return ApiDeleteFirewallSubtableRequest{
		ApiService: api,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return m.FirewallSubtableDetailResponse
func (api *FirewallApiService) DeleteFirewallSubtableExecute(r ApiDeleteFirewallSubtableRequest) (*m.FirewallSubtableDetailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.FirewallSubtableDetailResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.DeleteFirewallSubtable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/firewall/subtables/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		localVarQueryParams.Add("force", parameterToString(*r.force, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFirewallFwsetRequest struct {
	ctx context.Context
	ApiService *FirewallApiService
	name string
	osview *bool
}

// Show operating system level entries
func (r ApiGetFirewallFwsetRequest) Osview(osview bool) ApiGetFirewallFwsetRequest {
	r.osview = &osview
	return r
}

func (r ApiGetFirewallFwsetRequest) Execute() (m.FirewallFwsetDetailResponse, *http.Response, error) {
	return r.ApiService.GetFirewallFwsetExecute(r)
}

/*
GetFirewallFwset V2 Read firewall fwset data

Read firewall fwset data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name unique fwset name
 @return ApiGetFirewallFwsetRequest
*/
func (api *FirewallApiService) GetFirewallFwset(ctx context.Context, name string) ApiGetFirewallFwsetRequest {
	return ApiGetFirewallFwsetRequest{
		ApiService: api,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return m.FirewallFwsetDetailResponse
func (api *FirewallApiService) GetFirewallFwsetExecute(r ApiGetFirewallFwsetRequest) (m.FirewallFwsetDetailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  m.FirewallFwsetDetailResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.GetFirewallFwset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/firewall/fwsets/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.osview != nil {
		localVarQueryParams.Add("osview", parameterToString(*r.osview, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFirewallFwsetsRequest struct {
	ctx context.Context
	ApiService *FirewallApiService
}

func (r ApiGetFirewallFwsetsRequest) Execute() (m.FirewallFwsetListResponse, *http.Response, error) {
	return r.ApiService.GetFirewallFwsetsExecute(r)
}

/*
GetFirewallFwsets V2 Get firewall fwsets

Get list of all firewall fwsets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFirewallFwsetsRequest
*/
func (api *FirewallApiService) GetFirewallFwsets(ctx context.Context) ApiGetFirewallFwsetsRequest {
	return ApiGetFirewallFwsetsRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return m.FirewallFwsetListResponse
func (api *FirewallApiService) GetFirewallFwsetsExecute(r ApiGetFirewallFwsetsRequest) (m.FirewallFwsetListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  m.FirewallFwsetListResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.GetFirewallFwsets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/firewall/fwsets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFirewallRuleGroupRequest struct {
	ctx context.Context
	ApiService *FirewallApiService
	name string
}

func (r ApiGetFirewallRuleGroupRequest) Execute() (*m.RuleGroupDetailResponse, *http.Response, error) {
	return r.ApiService.GetFirewallRuleGroupExecute(r)
}

/*
GetFirewallRuleGroup V2 Read rule group details

Read rule group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name unique rule group name
 @return ApiGetFirewallRuleGroupRequest
*/
func (api *FirewallApiService) GetFirewallRuleGroup(ctx context.Context, name string) ApiGetFirewallRuleGroupRequest {
	return ApiGetFirewallRuleGroupRequest{
		ApiService: api,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return m.RuleGroupDetailResponse
func (api *FirewallApiService) GetFirewallRuleGroupExecute(r ApiGetFirewallRuleGroupRequest) (*m.RuleGroupDetailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.RuleGroupDetailResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.GetFirewallRuleGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/firewall/rules-groups/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFirewallRuleGroupsRequest struct {
	ctx context.Context
	ApiService *FirewallApiService
}

func (r ApiGetFirewallRuleGroupsRequest) Execute() (*m.RuleGroupsListResponse, *http.Response, error) {
	return r.ApiService.GetFirewallRuleGroupsExecute(r)
}

/*
GetFirewallRuleGroups V2 Get firewall rule groups

Get a list of firewall rule groups

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFirewallRuleGroupsRequest
*/
func (api *FirewallApiService) GetFirewallRuleGroups(ctx context.Context) ApiGetFirewallRuleGroupsRequest {
	return ApiGetFirewallRuleGroupsRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RuleGroupsListResponse
func (api *FirewallApiService) GetFirewallRuleGroupsExecute(r ApiGetFirewallRuleGroupsRequest) (*m.RuleGroupsListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.RuleGroupsListResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.GetFirewallRuleGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/firewall/rules-groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}


type ApiGetFirewallRulesRequest struct {
	ctx context.Context
	ApiService *FirewallApiService
	state *string
	groups *string
	osview *bool
	tables *string
}

// Filter rules by state, active or disabled
func (r ApiGetFirewallRulesRequest) State(state string) ApiGetFirewallRulesRequest {
	r.state = &state
	return r
}

// Filter by groups. Accepts csv.
func (r ApiGetFirewallRulesRequest) Groups(groups string) ApiGetFirewallRulesRequest {
	r.groups = &groups
	return r
}

// Show operating system level rules
func (r ApiGetFirewallRulesRequest) Osview(osview bool) ApiGetFirewallRulesRequest {
	r.osview = &osview
	return r
}

// Filter by tables. Accepts csv.
func (r ApiGetFirewallRulesRequest) Tables(tables string) ApiGetFirewallRulesRequest {
	r.tables = &tables
	return r
}

func (r ApiGetFirewallRulesRequest) Execute() (*m.FirewallRuleListResponse, *http.Response, error) {
	return r.ApiService.GetFirewallRulesExecute(r)
}

/*
GetFirewallRules V2 Get firewall rules

Get a list of firewall rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFirewallRulesRequest
*/
func (api *FirewallApiService) GetFirewallRules(ctx context.Context) ApiGetFirewallRulesRequest {
	return ApiGetFirewallRulesRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return m.FirewallRuleListResponse
func (api *FirewallApiService) GetFirewallRulesExecute(r ApiGetFirewallRulesRequest) (*m.FirewallRuleListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.FirewallRuleListResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.GetFirewallRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/firewall/rules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.state != nil {
		localVarQueryParams.Add("state", parameterToString(*r.state, ""))
	}
	if r.groups != nil {
		localVarQueryParams.Add("groups", parameterToString(*r.groups, ""))
	}
	if r.osview != nil {
		localVarQueryParams.Add("osview", parameterToString(*r.osview, ""))
	}
	if r.tables != nil {
		localVarQueryParams.Add("tables", parameterToString(*r.tables, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFirewallSubtableRequest struct {
	ctx context.Context
	ApiService *FirewallApiService
	name string
	osview *bool
}

// Show operating system level rules
func (r ApiGetFirewallSubtableRequest) Osview(osview bool) ApiGetFirewallSubtableRequest {
	r.osview = &osview
	return r
}

func (r ApiGetFirewallSubtableRequest) Execute() (*m.FirewallSubtableDetailResponse, *http.Response, error) {
	return r.ApiService.GetFirewallSubtableExecute(r)
}

/*
GetFirewallSubtable V2 Read firewall subtable data

Read firewall subtable data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name unique subtable name
 @return ApiGetFirewallSubtableRequest
*/
func (api *FirewallApiService) GetFirewallSubtable(ctx context.Context, name string) ApiGetFirewallSubtableRequest {
	return ApiGetFirewallSubtableRequest{
		ApiService: api,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return m.FirewallSubtableDetailResponse
func (api *FirewallApiService) GetFirewallSubtableExecute(r ApiGetFirewallSubtableRequest) (*m.FirewallSubtableDetailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.FirewallSubtableDetailResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.GetFirewallSubtable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/firewall/subtables/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.osview != nil {
		localVarQueryParams.Add("osview", parameterToString(*r.osview, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFirewallSubtablesRequest struct {
	ctx context.Context
	ApiService *FirewallApiService
}

func (r ApiGetFirewallSubtablesRequest) Execute() (*m.FirewallSubtableListResponse, *http.Response, error) {
	return r.ApiService.GetFirewallSubtablesExecute(r)
}

/*
GetFirewallSubtables V2 Get firewall subtables

Get list of all firewall subtables

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFirewallSubtablesRequest
*/
func (api *FirewallApiService) GetFirewallSubtables(ctx context.Context) ApiGetFirewallSubtablesRequest {
	return ApiGetFirewallSubtablesRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FirewallSubtableListResponse
func (api *FirewallApiService) GetFirewallSubtablesExecute(r ApiGetFirewallSubtablesRequest) (*m.FirewallSubtableListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.FirewallSubtableListResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.GetFirewallSubtables")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/firewall/subtables"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiImportFirewallRulesRequest struct {
	ctx context.Context
	ApiService *FirewallApiService
	importFirewallRulesRequest *m.ImportFirewallRulesRequest
}

func (r ApiImportFirewallRulesRequest) ImportFirewallRulesRequest(importFirewallRulesRequest m.ImportFirewallRulesRequest) ApiImportFirewallRulesRequest {
	r.importFirewallRulesRequest = &importFirewallRulesRequest
	return r
}

func (r ApiImportFirewallRulesRequest) Execute() (*m.FirewallRulesAndErrorsResponse, *http.Response, error) {
	return r.ApiService.ImportFirewallRulesExecute(r)
}

/*
ImportFirewallRules V2 Import firewall rules

Import list of firewall rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiImportFirewallRulesRequest
*/
func (api *FirewallApiService) ImportFirewallRules(ctx context.Context) ApiImportFirewallRulesRequest {
	return ApiImportFirewallRulesRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return m.FirewallRulesAndErrorsResponse
func (api *FirewallApiService) ImportFirewallRulesExecute(r ApiImportFirewallRulesRequest) (*m.FirewallRulesAndErrorsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.FirewallRulesAndErrorsResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.ImportFirewallRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/firewall/rules/import"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.importFirewallRulesRequest == nil {
		return localVarReturnValue, nil, reportError("importFirewallRulesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.importFirewallRulesRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCreateFirewallFwsetRequest struct {
	ctx context.Context
	ApiService *FirewallApiService
	createFirewallFwsetRequest *m.CreateFirewallFwsetRequest
}

func (r ApiPostCreateFirewallFwsetRequest) CreateFirewallFwsetRequest(createFirewallFwsetRequest m.CreateFirewallFwsetRequest) ApiPostCreateFirewallFwsetRequest {
	r.createFirewallFwsetRequest = &createFirewallFwsetRequest
	return r
}

func (r ApiPostCreateFirewallFwsetRequest) Execute() (*m.FirewallFwsetSaveResponse, *http.Response, error) {
	return r.ApiService.PostCreateFirewallFwsetExecute(r)
}

/*
PostCreateFirewallFwset V2 Create firewall fwset

Create firewall fwset

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCreateFirewallFwsetRequest
*/
func (api *FirewallApiService) PostCreateFirewallFwset(ctx context.Context) ApiPostCreateFirewallFwsetRequest {
	return ApiPostCreateFirewallFwsetRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FirewallFwsetSaveResponse
func (api *FirewallApiService) PostCreateFirewallFwsetExecute(r ApiPostCreateFirewallFwsetRequest) (*m.FirewallFwsetSaveResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.FirewallFwsetSaveResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.PostCreateFirewallFwset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/firewall/fwsets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createFirewallFwsetRequest == nil {
		return localVarReturnValue, nil, reportError("createFirewallFwsetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createFirewallFwsetRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCreateFirewallRuleRequest struct {
	ctx context.Context
	ApiService *FirewallApiService
	createFirewallRuleRequest *m.CreateFirewallRuleRequest
}

func (r ApiPostCreateFirewallRuleRequest) CreateFirewallRuleRequest(createFirewallRuleRequest m.CreateFirewallRuleRequest) ApiPostCreateFirewallRuleRequest {
	r.createFirewallRuleRequest = &createFirewallRuleRequest
	return r
}

func (r ApiPostCreateFirewallRuleRequest) Execute() (*m.FirewallRuleSaveResponse, *http.Response, error) {
	return r.ApiService.PostCreateFirewallRuleExecute(r)
}

/*
PostCreateFirewallRule V2 Create firewall rule

Create a VNS3 firewall rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCreateFirewallRuleRequest
*/
func (api *FirewallApiService) PostCreateFirewallRule(ctx context.Context) ApiPostCreateFirewallRuleRequest {
	return ApiPostCreateFirewallRuleRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return m.FirewallRuleSaveResponse
func (api *FirewallApiService) PostCreateFirewallRuleExecute(r ApiPostCreateFirewallRuleRequest) (*m.FirewallRuleSaveResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.FirewallRuleSaveResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.PostCreateFirewallRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/firewall/rules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createFirewallRuleRequest == nil {
		return localVarReturnValue, nil, reportError("createFirewallRuleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createFirewallRuleRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCreateFirewallRuleGroupRequest struct {
	ctx context.Context
	ApiService *FirewallApiService
	createRuleGroupRequest *m.CreateFirewallRuleGroupRequest
}

func (r ApiPostCreateFirewallRuleGroupRequest) CreateFirewallRuleGroupRequest(createRuleGroupRequest m.CreateFirewallRuleGroupRequest) ApiPostCreateFirewallRuleGroupRequest {
	r.createRuleGroupRequest = &createRuleGroupRequest
	return r
}

func (r ApiPostCreateFirewallRuleGroupRequest) Execute() (*m.RuleGroupDetailResponse, *http.Response, error) {
	return r.ApiService.PostCreateFirewallRuleGroupExecute(r)
}

/*
PostCreateFirewallRuleGroup V2 Create firewall rule group

Create a VNS3 firewall rule group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCreateFirewallRuleGroupRequest
*/
func (api *FirewallApiService) PostCreateFirewallRuleGroup(ctx context.Context) ApiPostCreateFirewallRuleGroupRequest {
	return ApiPostCreateFirewallRuleGroupRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return m.RuleGroupDetailResponse
func (api *FirewallApiService) PostCreateFirewallRuleGroupExecute(r ApiPostCreateFirewallRuleGroupRequest) (*m.RuleGroupDetailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.RuleGroupDetailResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.PostCreateFirewallRuleGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/firewall/rules-groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createRuleGroupRequest == nil {
		return localVarReturnValue, nil, reportError("createRuleGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createRuleGroupRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCreateFirewallSubtableRequest struct {
	ctx context.Context
	ApiService *FirewallApiService
	createFirewallSubtableRequest *m.CreateFirewallSubtableRequest
}

func (r ApiPostCreateFirewallSubtableRequest) CreateFirewallSubtableRequest(createFirewallSubtableRequest m.CreateFirewallSubtableRequest) ApiPostCreateFirewallSubtableRequest {
	r.createFirewallSubtableRequest = &createFirewallSubtableRequest
	return r
}

func (r ApiPostCreateFirewallSubtableRequest) Execute() (*m.FirewallSubtableSaveResponse, *http.Response, error) {
	return r.ApiService.PostCreateFirewallSubtableExecute(r)
}

/*
PostCreateFirewallSubtable V2 Create firewall subtable

Create firewall subtable

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCreateFirewallSubtableRequest
*/
func (api *FirewallApiService) PostCreateFirewallSubtable(ctx context.Context) ApiPostCreateFirewallSubtableRequest {
	return ApiPostCreateFirewallSubtableRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return m.FirewallSubtableSaveResponse
func (api *FirewallApiService) PostCreateFirewallSubtableExecute(r ApiPostCreateFirewallSubtableRequest) (*m.FirewallSubtableSaveResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.FirewallSubtableSaveResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.PostCreateFirewallSubtable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/firewall/subtables"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createFirewallSubtableRequest == nil {
		return localVarReturnValue, nil, reportError("createFirewallSubtableRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createFirewallSubtableRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutFirewallActionRequest struct {
	ctx context.Context
	ApiService *FirewallApiService
	firewallActionRequest *m.FirewallActionRequest
}

func (r ApiPutFirewallActionRequest) FirewallActionRequest(firewallActionRequest m.FirewallActionRequest) ApiPutFirewallActionRequest {
	r.firewallActionRequest = &firewallActionRequest
	return r
}

func (r ApiPutFirewallActionRequest) Execute() (*m.SimpleStatusResponse, *http.Response, error) {
	return r.ApiService.PutFirewallActionExecute(r)
}

/*
PutFirewallAction V2 Put firewall action

Take an action on the firewall

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutFirewallActionRequest
*/
func (api *FirewallApiService) PutFirewallAction(ctx context.Context) ApiPutFirewallActionRequest {
	return ApiPutFirewallActionRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return m.SimpleStatusResponse
func (api *FirewallApiService) PutFirewallActionExecute(r ApiPutFirewallActionRequest) (*m.SimpleStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.SimpleStatusResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.PutFirewallAction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/firewall/actions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.firewallActionRequest == nil {
		return localVarReturnValue, nil, reportError("firewallActionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.firewallActionRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutOverwriteFirewallRequest struct {
	ctx context.Context
	ApiService *FirewallApiService
	overwriteRequest *m.FirewallOverwriteRequest
}

func (r ApiPutOverwriteFirewallRequest) OverwriteRequest(overwriteRequest m.FirewallOverwriteRequest) ApiPutOverwriteFirewallRequest {
	r.overwriteRequest = &overwriteRequest
	return r
}

func (r ApiPutOverwriteFirewallRequest) Execute() (*m.FirewallOverwriteResponse, *http.Response, error) {
	return r.ApiService.PutOverwriteFirewallExecute(r)
}

/*
PutOverwriteFirewall V2 Put firewall

Put/Overwrite entire firewall. Careful!

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutOverwriteFirewallRequest
*/
func (api *FirewallApiService) PutOverwriteFirewall(ctx context.Context) ApiPutOverwriteFirewallRequest {
	return ApiPutOverwriteFirewallRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return m.FirewallOverwriteResponse
func (api *FirewallApiService) PutOverwriteFirewallExecute(r ApiPutOverwriteFirewallRequest) (*m.FirewallOverwriteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.FirewallOverwriteResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.PutOverwriteFirewall")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/firewall/rules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.overwriteRequest == nil {
		return localVarReturnValue, nil, reportError("overwriteRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.overwriteRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutUpdateFirewallFwsetRequest struct {
	ctx context.Context
	ApiService *FirewallApiService
	name string
	updateFirewallFwsetRequest *m.UpdateFirewallFwsetRequest
}

func (r ApiPutUpdateFirewallFwsetRequest) UpdateFirewallFwsetRequest(updateFirewallFwsetRequest m.UpdateFirewallFwsetRequest) ApiPutUpdateFirewallFwsetRequest {
	r.updateFirewallFwsetRequest = &updateFirewallFwsetRequest
	return r
}

func (r ApiPutUpdateFirewallFwsetRequest) Execute() (*m.FirewallFwsetSaveResponse, *http.Response, error) {
	return r.ApiService.PutUpdateFirewallFwsetExecute(r)
}

/*
PutUpdateFirewallFwset V2 Update firewall fwset

Update firewall fwset

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name unique fwset name
 @return ApiPutUpdateFirewallFwsetRequest
*/
func (api *FirewallApiService) PutUpdateFirewallFwset(ctx context.Context, name string) ApiPutUpdateFirewallFwsetRequest {
	return ApiPutUpdateFirewallFwsetRequest{
		ApiService: api,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return m.FirewallFwsetSaveResponse
func (api *FirewallApiService) PutUpdateFirewallFwsetExecute(r ApiPutUpdateFirewallFwsetRequest) (*m.FirewallFwsetSaveResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.FirewallFwsetSaveResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.PutUpdateFirewallFwset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/firewall/fwsets/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFirewallFwsetRequest == nil {
		return localVarReturnValue, nil, reportError("updateFirewallFwsetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFirewallFwsetRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutUpdateFirewallRuleRequest struct {
	ctx context.Context
	ApiService *FirewallApiService
	id string
	updateFirewallRuleRequest *m.UpdateFirewallRuleRequest
}

func (r ApiPutUpdateFirewallRuleRequest) UpdateFirewallRuleRequest(updateFirewallRuleRequest m.UpdateFirewallRuleRequest) ApiPutUpdateFirewallRuleRequest {
	r.updateFirewallRuleRequest = &updateFirewallRuleRequest
	return r
}

func (r ApiPutUpdateFirewallRuleRequest) Execute() (*m.FirewallRuleDetailResponse, *http.Response, error) {
	return r.ApiService.PutUpdateFirewallRuleExecute(r)
}

/*
PutUpdateFirewallRule V2 Update firewall rule

Update firewall rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Rule ID
 @return ApiPutUpdateFirewallRuleRequest
*/
func (api *FirewallApiService) PutUpdateFirewallRule(ctx context.Context, id string) ApiPutUpdateFirewallRuleRequest {
	return ApiPutUpdateFirewallRuleRequest{
		ApiService: api,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return m.FirewallRuleDetailResponse
func (api *FirewallApiService) PutUpdateFirewallRuleExecute(r ApiPutUpdateFirewallRuleRequest) (*m.FirewallRuleDetailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.FirewallRuleDetailResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.PutUpdateFirewallRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/firewall/rules/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFirewallRuleRequest == nil {
		return localVarReturnValue, nil, reportError("updateFirewallRuleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFirewallRuleRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutUpdateFirewallRuleGroupRequest struct {
	ctx context.Context
	ApiService *FirewallApiService
	name string
	updateFirewallRuleGroupRequest *m.UpdateFirewallRuleGroupRequest
}

func (r ApiPutUpdateFirewallRuleGroupRequest) UpdateFirewallRuleGroupRequest(updateFirewallRuleGroupRequest m.UpdateFirewallRuleGroupRequest) ApiPutUpdateFirewallRuleGroupRequest {
	r.updateFirewallRuleGroupRequest = &updateFirewallRuleGroupRequest
	return r
}

func (r ApiPutUpdateFirewallRuleGroupRequest) Execute() (*m.RuleGroupDetailResponse, *http.Response, error) {
	return r.ApiService.PutUpdateFirewallRuleGroupExecute(r)
}

/*
PutUpdateFirewallRuleGroup V2 Update rule group data

Update rule group data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name unique rule group name
 @return ApiPutUpdateFirewallRuleGroupRequest
*/
func (api *FirewallApiService) PutUpdateFirewallRuleGroup(ctx context.Context, name string) ApiPutUpdateFirewallRuleGroupRequest {
	return ApiPutUpdateFirewallRuleGroupRequest{
		ApiService: api,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return m.RuleGroupDetailResponse
func (api *FirewallApiService) PutUpdateFirewallRuleGroupExecute(r ApiPutUpdateFirewallRuleGroupRequest) (*m.RuleGroupDetailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.RuleGroupDetailResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.PutUpdateFirewallRuleGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/firewall/rules-groups/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFirewallRuleGroupRequest == nil {
		return localVarReturnValue, nil, reportError("updateFirewallRuleGroupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFirewallRuleGroupRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutUpdateFirewallSubtableRequest struct {
	ctx context.Context
	ApiService *FirewallApiService
	name string
	updateFirewallSubtableRequest *m.UpdateFirewallSubtableRequest
}

func (r ApiPutUpdateFirewallSubtableRequest) UpdateFirewallSubtableRequest(updateFirewallSubtableRequest m.UpdateFirewallSubtableRequest) ApiPutUpdateFirewallSubtableRequest {
	r.updateFirewallSubtableRequest = &updateFirewallSubtableRequest
	return r
}

func (r ApiPutUpdateFirewallSubtableRequest) Execute() (*m.FirewallSubtableSaveResponse, *http.Response, error) {
	return r.ApiService.PutUpdateFirewallSubtableExecute(r)
}

/*
PutUpdateFirewallSubtable V2 Update firewall subtable

Update firewall subtable

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name unique subtable name
 @return ApiPutUpdateFirewallSubtableRequest
*/
func (api *FirewallApiService) PutUpdateFirewallSubtable(ctx context.Context, name string) ApiPutUpdateFirewallSubtableRequest {
	return ApiPutUpdateFirewallSubtableRequest{
		ApiService: api,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return m.FirewallSubtableSaveResponse
func (api *FirewallApiService) PutUpdateFirewallSubtableExecute(r ApiPutUpdateFirewallSubtableRequest) (*m.FirewallSubtableSaveResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.FirewallSubtableSaveResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.PutUpdateFirewallSubtable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/firewall/subtables/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFirewallSubtableRequest == nil {
		return localVarReturnValue, nil, reportError("updateFirewallSubtableRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFirewallSubtableRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}


// TODO: Question? Show we support the _old_ firewall endpoints in SDK? im leaning no.

// type ApiDeleteFirewallFwsetV1Request struct {
// 	ctx context.Context
// 	ApiService *FirewallApiService
// 	firewallFwsetDeleteRequest *FirewallFwsetDeleteRequest
// }

// func (r ApiDeleteFirewallFwsetV1Request) FirewallFwsetDeleteRequest(firewallFwsetDeleteRequest FirewallFwsetDeleteRequest) ApiDeleteFirewallFwsetV1Request {
// 	r.firewallFwsetDeleteRequest = &firewallFwsetDeleteRequest
// 	return r
// }

// func (r ApiDeleteFirewallFwsetV1Request) Execute() (*Object, *http.Response, error) {
// 	return r.ApiService.DeleteFirewallFwsetV1Execute(r)
// }

// /*
// DeleteFirewallFwsetV1 V1 Delete firewall Fwset

// Delete Firewall Fwset by name or rules

//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @return ApiDeleteFirewallFwsetV1Request
// */
// func (api *FirewallApiService) DeleteFirewallFwsetV1(ctx context.Context) ApiDeleteFirewallFwsetV1Request {
// 	return ApiDeleteFirewallFwsetV1Request{
// 		ApiService: api,
// 		ctx: ctx,
// 	}
// }

// // Execute executes the request
// //  @return Object
// func (api *FirewallApiService) DeleteFirewallFwsetV1Execute(r ApiDeleteFirewallFwsetV1Request) (*Object, *http.Response, error) {
// 	var (
// 		localVarHTTPMethod   = http.MethodDelete
// 		localVarPostBody     interface{}
// 		formFiles            []formFile
// 		localVarReturnValue  *Object
// 	)

// 	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.DeleteFirewallFwsetV1")
// 	if err != nil {
// 		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
// 	}

// 	localVarPath := localBasePath + "/firewall/fwsets"

// 	localVarHeaderParams := make(map[string]string)
// 	localVarQueryParams := url.Values{}
// 	localVarFormParams := url.Values{}
// 	if r.firewallFwsetDeleteRequest == nil {
// 		return localVarReturnValue, nil, reportError("firewallFwsetDeleteRequest is required and must be specified")
// 	}

// 	// to determine the Content-Type header
// 	localVarHTTPContentTypes := []string{"application/json"}

// 	// set Content-Type header
// 	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
// 	if localVarHTTPContentType != "" {
// 		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
// 	}

// 	// to determine the Accept header
// 	localVarHTTPHeaderAccepts := []string{"application/json"}

// 	// set Accept header
// 	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
// 	if localVarHTTPHeaderAccept != "" {
// 		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
// 	}
// 	// body params
// 	localVarPostBody = r.firewallFwsetDeleteRequest
// 	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
// 	if err != nil {
// 		return localVarReturnValue, nil, err
// 	}

// 	localVarHTTPResponse, err := api.client.callAPI(req)
// 	if err != nil || localVarHTTPResponse == nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
// 	localVarHTTPResponse.Body.Close()
// 	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
// 	if err != nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	if localVarHTTPResponse.StatusCode >= 300 {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: localVarHTTPResponse.Status,
// 		}
// 		if localVarHTTPResponse.StatusCode == 400 {
// 			var v m.ErrorResponse
// 			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 			newErr.model = v
// 			return localVarReturnValue, localVarHTTPResponse, newErr
// 		}
// 		if localVarHTTPResponse.StatusCode == 403 {
// 			var v m.ErrorResponse
// 			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 			newErr.model = v
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 	if err != nil {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: err.Error(),
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	return localVarReturnValue, localVarHTTPResponse, nil
// }


// type ApiDeleteFirewallRuleByPositionV1Request struct {
// 	ctx context.Context
// 	ApiService *FirewallApiService
// 	position int32
// }

// func (r ApiDeleteFirewallRuleByPositionV1Request) Execute() (*Object, *http.Response, error) {
// 	return r.ApiService.DeleteFirewallRuleByPositionV1Execute(r)
// }

// /*
// DeleteFirewallRuleByPositionV1 V1 Delete firewall rule by position

// V1 API. Delete firewall rule by position in the firewall. The firewall is 0 indexed. So deleting position 0 will remove the first rule in the firewall and the second rule will become the first. We recommend using v2/firewall/rules endpoints.


//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @param position index position for firewall rule, 0 is first
//  @return ApiDeleteFirewallRuleByPositionV1Request
// */
// func (api *FirewallApiService) DeleteFirewallRuleByPositionV1(ctx context.Context, position int32) ApiDeleteFirewallRuleByPositionV1Request {
// 	return ApiDeleteFirewallRuleByPositionV1Request{
// 		ApiService: api,
// 		ctx: ctx,
// 		position: position,
// 	}
// }

// // Execute executes the request
// //  @return Object
// func (api *FirewallApiService) DeleteFirewallRuleByPositionV1Execute(r ApiDeleteFirewallRuleByPositionV1Request) (*Object, *http.Response, error) {
// 	var (
// 		localVarHTTPMethod   = http.MethodDelete
// 		localVarPostBody     interface{}
// 		formFiles            []formFile
// 		localVarReturnValue  *Object
// 	)

// 	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.DeleteFirewallRuleByPositionV1")
// 	if err != nil {
// 		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
// 	}

// 	localVarPath := localBasePath + "/firewall/rules/{position}"
// 	localVarPath = strings.Replace(localVarPath, "{"+"position"+"}", url.PathEscape(parameterToString(r.position, "")), -1)

// 	localVarHeaderParams := make(map[string]string)
// 	localVarQueryParams := url.Values{}
// 	localVarFormParams := url.Values{}

// 	// to determine the Content-Type header
// 	localVarHTTPContentTypes := []string{}

// 	// set Content-Type header
// 	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
// 	if localVarHTTPContentType != "" {
// 		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
// 	}

// 	// to determine the Accept header
// 	localVarHTTPHeaderAccepts := []string{"application/json"}

// 	// set Accept header
// 	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
// 	if localVarHTTPHeaderAccept != "" {
// 		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
// 	}
// 	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
// 	if err != nil {
// 		return localVarReturnValue, nil, err
// 	}

// 	localVarHTTPResponse, err := api.client.callAPI(req)
// 	if err != nil || localVarHTTPResponse == nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
// 	localVarHTTPResponse.Body.Close()
// 	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
// 	if err != nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	if localVarHTTPResponse.StatusCode >= 300 {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: localVarHTTPResponse.Status,
// 		}
// 		if localVarHTTPResponse.StatusCode == 400 {
// 			var v m.ErrorResponse
// 			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 			newErr.model = v
// 			return localVarReturnValue, localVarHTTPResponse, newErr
// 		}
// 		if localVarHTTPResponse.StatusCode == 403 {
// 			var v m.ErrorResponse
// 			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 			newErr.model = v
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 	if err != nil {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: err.Error(),
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	return localVarReturnValue, localVarHTTPResponse, nil
// }

// type ApiDeleteFirewallRuleByRuleRequest struct {
// 	ctx context.Context
// 	ApiService *FirewallApiService
// 	deleteFirewallRuleRequest *DeleteFirewallRuleRequest
// }

// func (r ApiDeleteFirewallRuleByRuleRequest) DeleteFirewallRuleRequest(deleteFirewallRuleRequest DeleteFirewallRuleRequest) ApiDeleteFirewallRuleByRuleRequest {
// 	r.deleteFirewallRuleRequest = &deleteFirewallRuleRequest
// 	return r
// }

// func (r ApiDeleteFirewallRuleByRuleRequest) Execute() (*Object, *http.Response, error) {
// 	return r.ApiService.DeleteFirewallRuleByRuleExecute(r)
// }

// /*
// DeleteFirewallRuleByRule V1 Delete firewall rule

// V1 API. Delete firewall rule by passing the actual rule to delete. We recommend using v2/firewall/rules endpoints.


//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @return ApiDeleteFirewallRuleByRuleRequest
// */
// func (api *FirewallApiService) DeleteFirewallRuleByRule(ctx context.Context) ApiDeleteFirewallRuleByRuleRequest {
// 	return ApiDeleteFirewallRuleByRuleRequest{
// 		ApiService: api,
// 		ctx: ctx,
// 	}
// }

// // Execute executes the request
// //  @return Object
// func (api *FirewallApiService) DeleteFirewallRuleByRuleExecute(r ApiDeleteFirewallRuleByRuleRequest) (*Object, *http.Response, error) {
// 	var (
// 		localVarHTTPMethod   = http.MethodDelete
// 		localVarPostBody     interface{}
// 		formFiles            []formFile
// 		localVarReturnValue  *Object
// 	)

// 	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.DeleteFirewallRuleByRule")
// 	if err != nil {
// 		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
// 	}

// 	localVarPath := localBasePath + "/firewall/rules"

// 	localVarHeaderParams := make(map[string]string)
// 	localVarQueryParams := url.Values{}
// 	localVarFormParams := url.Values{}
// 	if r.deleteFirewallRuleRequest == nil {
// 		return localVarReturnValue, nil, reportError("deleteFirewallRuleRequest is required and must be specified")
// 	}

// 	// to determine the Content-Type header
// 	localVarHTTPContentTypes := []string{"application/json"}

// 	// set Content-Type header
// 	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
// 	if localVarHTTPContentType != "" {
// 		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
// 	}

// 	// to determine the Accept header
// 	localVarHTTPHeaderAccepts := []string{"application/json"}

// 	// set Accept header
// 	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
// 	if localVarHTTPHeaderAccept != "" {
// 		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
// 	}
// 	// body params
// 	localVarPostBody = r.deleteFirewallRuleRequest
// 	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
// 	if err != nil {
// 		return localVarReturnValue, nil, err
// 	}

// 	localVarHTTPResponse, err := api.client.callAPI(req)
// 	if err != nil || localVarHTTPResponse == nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
// 	localVarHTTPResponse.Body.Close()
// 	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
// 	if err != nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	if localVarHTTPResponse.StatusCode >= 300 {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: localVarHTTPResponse.Status,
// 		}
// 		if localVarHTTPResponse.StatusCode == 400 {
// 			var v m.ErrorResponse
// 			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 			newErr.model = v
// 			return localVarReturnValue, localVarHTTPResponse, newErr
// 		}
// 		if localVarHTTPResponse.StatusCode == 403 {
// 			var v m.ErrorResponse
// 			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 			newErr.model = v
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 	if err != nil {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: err.Error(),
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	return localVarReturnValue, localVarHTTPResponse, nil
// }


// type ApiDeleteFirewallSubgroupV1Request struct {
// 	ctx context.Context
// 	ApiService *FirewallApiService
// 	firewallSubgroupDeleteRequest *FirewallSubgroupDeleteRequest
// }

// func (r ApiDeleteFirewallSubgroupV1Request) FirewallSubgroupDeleteRequest(firewallSubgroupDeleteRequest FirewallSubgroupDeleteRequest) ApiDeleteFirewallSubgroupV1Request {
// 	r.firewallSubgroupDeleteRequest = &firewallSubgroupDeleteRequest
// 	return r
// }

// func (r ApiDeleteFirewallSubgroupV1Request) Execute() (*Object, *http.Response, error) {
// 	return r.ApiService.DeleteFirewallSubgroupV1Execute(r)
// }

// /*
// DeleteFirewallSubgroupV1 V1 Delete firewall subgroup

// V1 API. Delete Firewall subgroup by name or rules. We recommend using v2/firewall/subtables endpoints.

//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @return ApiDeleteFirewallSubgroupV1Request
// */
// func (api *FirewallApiService) DeleteFirewallSubgroupV1(ctx context.Context) ApiDeleteFirewallSubgroupV1Request {
// 	return ApiDeleteFirewallSubgroupV1Request{
// 		ApiService: api,
// 		ctx: ctx,
// 	}
// }

// // Execute executes the request
// //  @return Object
// func (api *FirewallApiService) DeleteFirewallSubgroupV1Execute(r ApiDeleteFirewallSubgroupV1Request) (*Object, *http.Response, error) {
// 	var (
// 		localVarHTTPMethod   = http.MethodDelete
// 		localVarPostBody     interface{}
// 		formFiles            []formFile
// 		localVarReturnValue  *Object
// 	)

// 	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.DeleteFirewallSubgroupV1")
// 	if err != nil {
// 		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
// 	}

// 	localVarPath := localBasePath + "/firewall/rules/subgroup"

// 	localVarHeaderParams := make(map[string]string)
// 	localVarQueryParams := url.Values{}
// 	localVarFormParams := url.Values{}
// 	if r.firewallSubgroupDeleteRequest == nil {
// 		return localVarReturnValue, nil, reportError("firewallSubgroupDeleteRequest is required and must be specified")
// 	}

// 	// to determine the Content-Type header
// 	localVarHTTPContentTypes := []string{"application/json"}

// 	// set Content-Type header
// 	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
// 	if localVarHTTPContentType != "" {
// 		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
// 	}

// 	// to determine the Accept header
// 	localVarHTTPHeaderAccepts := []string{"application/json"}

// 	// set Accept header
// 	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
// 	if localVarHTTPHeaderAccept != "" {
// 		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
// 	}
// 	// body params
// 	localVarPostBody = r.firewallSubgroupDeleteRequest
// 	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
// 	if err != nil {
// 		return localVarReturnValue, nil, err
// 	}

// 	localVarHTTPResponse, err := api.client.callAPI(req)
// 	if err != nil || localVarHTTPResponse == nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
// 	localVarHTTPResponse.Body.Close()
// 	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
// 	if err != nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	if localVarHTTPResponse.StatusCode >= 300 {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: localVarHTTPResponse.Status,
// 		}
// 		if localVarHTTPResponse.StatusCode == 403 {
// 			var v m.ErrorResponse
// 			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 			newErr.model = v
// 			return localVarReturnValue, localVarHTTPResponse, newErr
// 		}
// 		if localVarHTTPResponse.StatusCode == 404 {
// 			var v m.ErrorResponse
// 			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 			newErr.model = v
// 			return localVarReturnValue, localVarHTTPResponse, newErr
// 		}
// 		if localVarHTTPResponse.StatusCode == 410 {
// 			var v m.ErrorResponse
// 			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 			newErr.model = v
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 	if err != nil {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: err.Error(),
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	return localVarReturnValue, localVarHTTPResponse, nil
// }


// type ApiGetFirewallFwsetsV1Request struct {
// 	ctx context.Context
// 	ApiService *FirewallApiService
// 	name *string
// 	verbose *bool
// }

// // name of resource
// func (r ApiGetFirewallFwsetsV1Request) Name(name string) ApiGetFirewallFwsetsV1Request {
// 	r.name = &name
// 	return r
// }

// // True for verbose output
// func (r ApiGetFirewallFwsetsV1Request) Verbose(verbose bool) ApiGetFirewallFwsetsV1Request {
// 	r.verbose = &verbose
// 	return r
// }

// func (r ApiGetFirewallFwsetsV1Request) Execute() (*FirewallFwSetListResponse, *http.Response, error) {
// 	return r.ApiService.GetFirewallFwsetsV1Execute(r)
// }

// /*
// GetFirewallFwsetsV1 V1 Get firewall Fwsets

// Get a list of current firewall rule sets. These are IPsets that allow for faster matching of rules against IPs.  See http://ipset.netfilter.org for more details.


//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @return ApiGetFirewallFwsetsV1Request
// */
// func (api *FirewallApiService) GetFirewallFwsetsV1(ctx context.Context) ApiGetFirewallFwsetsV1Request {
// 	return ApiGetFirewallFwsetsV1Request{
// 		ApiService: api,
// 		ctx: ctx,
// 	}
// }

// // Execute executes the request
// //  @return FirewallFwSetListResponse
// func (api *FirewallApiService) GetFirewallFwsetsV1Execute(r ApiGetFirewallFwsetsV1Request) (*FirewallFwSetListResponse, *http.Response, error) {
// 	var (
// 		localVarHTTPMethod   = http.MethodGet
// 		localVarPostBody     interface{}
// 		formFiles            []formFile
// 		localVarReturnValue  *FirewallFwSetListResponse
// 	)

// 	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.GetFirewallFwsetsV1")
// 	if err != nil {
// 		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
// 	}

// 	localVarPath := localBasePath + "/firewall/fwsets"

// 	localVarHeaderParams := make(map[string]string)
// 	localVarQueryParams := url.Values{}
// 	localVarFormParams := url.Values{}

// 	if r.name != nil {
// 		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
// 	}
// 	if r.verbose != nil {
// 		localVarQueryParams.Add("verbose", parameterToString(*r.verbose, ""))
// 	}
// 	// to determine the Content-Type header
// 	localVarHTTPContentTypes := []string{}

// 	// set Content-Type header
// 	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
// 	if localVarHTTPContentType != "" {
// 		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
// 	}

// 	// to determine the Accept header
// 	localVarHTTPHeaderAccepts := []string{"application/json"}

// 	// set Accept header
// 	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
// 	if localVarHTTPHeaderAccept != "" {
// 		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
// 	}
// 	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
// 	if err != nil {
// 		return localVarReturnValue, nil, err
// 	}

// 	localVarHTTPResponse, err := api.client.callAPI(req)
// 	if err != nil || localVarHTTPResponse == nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
// 	localVarHTTPResponse.Body.Close()
// 	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
// 	if err != nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	if localVarHTTPResponse.StatusCode >= 300 {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: localVarHTTPResponse.Status,
// 		}
// 		if localVarHTTPResponse.StatusCode == 403 {
// 			var v m.ErrorResponse
// 			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 			newErr.model = v
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 	if err != nil {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: err.Error(),
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	return localVarReturnValue, localVarHTTPResponse, nil
// }


// type ApiGetFirewallRuleSubgroupsV1Request struct {
// 	ctx context.Context
// 	ApiService *FirewallApiService
// 	name *string
// 	verbose *bool
// }

// // name of resource
// func (r ApiGetFirewallRuleSubgroupsV1Request) Name(name string) ApiGetFirewallRuleSubgroupsV1Request {
// 	r.name = &name
// 	return r
// }

// // True for verbose output
// func (r ApiGetFirewallRuleSubgroupsV1Request) Verbose(verbose bool) ApiGetFirewallRuleSubgroupsV1Request {
// 	r.verbose = &verbose
// 	return r
// }

// func (r ApiGetFirewallRuleSubgroupsV1Request) Execute() (*FirewallSubgroupListResponse, *http.Response, error) {
// 	return r.ApiService.GetFirewallRuleSubgroupsV1Execute(r)
// }

// /*
// GetFirewallRuleSubgroupsV1 V1 Get firewall subgroups

// Get a list of current firewall rules at subgroup (chained rules). We recommend using v2/firewall/subtables endpoints.


//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @return ApiGetFirewallRuleSubgroupsV1Request
// */
// func (api *FirewallApiService) GetFirewallRuleSubgroupsV1(ctx context.Context) ApiGetFirewallRuleSubgroupsV1Request {
// 	return ApiGetFirewallRuleSubgroupsV1Request{
// 		ApiService: api,
// 		ctx: ctx,
// 	}
// }

// // Execute executes the request
// //  @return FirewallSubgroupListResponse
// func (api *FirewallApiService) GetFirewallRuleSubgroupsV1Execute(r ApiGetFirewallRuleSubgroupsV1Request) (*FirewallSubgroupListResponse, *http.Response, error) {
// 	var (
// 		localVarHTTPMethod   = http.MethodGet
// 		localVarPostBody     interface{}
// 		formFiles            []formFile
// 		localVarReturnValue  *FirewallSubgroupListResponse
// 	)

// 	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.GetFirewallRuleSubgroupsV1")
// 	if err != nil {
// 		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
// 	}

// 	localVarPath := localBasePath + "/firewall/rules/subgroup"

// 	localVarHeaderParams := make(map[string]string)
// 	localVarQueryParams := url.Values{}
// 	localVarFormParams := url.Values{}

// 	if r.name != nil {
// 		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
// 	}
// 	if r.verbose != nil {
// 		localVarQueryParams.Add("verbose", parameterToString(*r.verbose, ""))
// 	}
// 	// to determine the Content-Type header
// 	localVarHTTPContentTypes := []string{}

// 	// set Content-Type header
// 	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
// 	if localVarHTTPContentType != "" {
// 		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
// 	}

// 	// to determine the Accept header
// 	localVarHTTPHeaderAccepts := []string{"application/json"}

// 	// set Accept header
// 	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
// 	if localVarHTTPHeaderAccept != "" {
// 		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
// 	}
// 	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
// 	if err != nil {
// 		return localVarReturnValue, nil, err
// 	}

// 	localVarHTTPResponse, err := api.client.callAPI(req)
// 	if err != nil || localVarHTTPResponse == nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
// 	localVarHTTPResponse.Body.Close()
// 	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
// 	if err != nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	if localVarHTTPResponse.StatusCode >= 300 {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: localVarHTTPResponse.Status,
// 		}
// 		if localVarHTTPResponse.StatusCode == 403 {
// 			var v m.ErrorResponse
// 			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 			newErr.model = v
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 	if err != nil {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: err.Error(),
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	return localVarReturnValue, localVarHTTPResponse, nil
// }


// type ApiGetFirewallRulesV1Request struct {
// 	ctx context.Context
// 	ApiService *FirewallApiService
// }

// func (r ApiGetFirewallRulesV1Request) Execute() (*FirewallRuleListResponse, *http.Response, error) {
// 	return r.ApiService.GetFirewallRulesV1Execute(r)
// }

// /*
// GetFirewallRulesV1 V1 Get firewall rules

// V1 API. Get a list of current firewall rules. We recommend using v2/firewall/rules endpoints.

//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @return ApiGetFirewallRulesV1Request
// */
// func (api *FirewallApiService) GetFirewallRulesV1(ctx context.Context) ApiGetFirewallRulesV1Request {
// 	return ApiGetFirewallRulesV1Request{
// 		ApiService: api,
// 		ctx: ctx,
// 	}
// }

// // Execute executes the request
// //  @return FirewallRuleListResponse
// func (api *FirewallApiService) GetFirewallRulesV1Execute(r ApiGetFirewallRulesV1Request) (*FirewallRuleListResponse, *http.Response, error) {
// 	var (
// 		localVarHTTPMethod   = http.MethodGet
// 		localVarPostBody     interface{}
// 		formFiles            []formFile
// 		localVarReturnValue  *FirewallRuleListResponse
// 	)

// 	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.GetFirewallRulesV1")
// 	if err != nil {
// 		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
// 	}

// 	localVarPath := localBasePath + "/firewall/rules"

// 	localVarHeaderParams := make(map[string]string)
// 	localVarQueryParams := url.Values{}
// 	localVarFormParams := url.Values{}

// 	// to determine the Content-Type header
// 	localVarHTTPContentTypes := []string{}

// 	// set Content-Type header
// 	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
// 	if localVarHTTPContentType != "" {
// 		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
// 	}

// 	// to determine the Accept header
// 	localVarHTTPHeaderAccepts := []string{"application/json"}

// 	// set Accept header
// 	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
// 	if localVarHTTPHeaderAccept != "" {
// 		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
// 	}
// 	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
// 	if err != nil {
// 		return localVarReturnValue, nil, err
// 	}

// 	localVarHTTPResponse, err := api.client.callAPI(req)
// 	if err != nil || localVarHTTPResponse == nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
// 	localVarHTTPResponse.Body.Close()
// 	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
// 	if err != nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	if localVarHTTPResponse.StatusCode >= 300 {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: localVarHTTPResponse.Status,
// 		}
// 		if localVarHTTPResponse.StatusCode == 403 {
// 			var v m.ErrorResponse
// 			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 			newErr.model = v
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 	if err != nil {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: err.Error(),
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	return localVarReturnValue, localVarHTTPResponse, nil
// }


// type ApiPostCreateFirewallFwsetV1Request struct {
// 	ctx context.Context
// 	ApiService *FirewallApiService
// 	createFwsetRequest *CreateFwsetRequest
// }

// func (r ApiPostCreateFirewallFwsetV1Request) CreateFwsetRequest(createFwsetRequest CreateFwsetRequest) ApiPostCreateFirewallFwsetV1Request {
// 	r.createFwsetRequest = &createFwsetRequest
// 	return r
// }

// func (r ApiPostCreateFirewallFwsetV1Request) Execute() (*PostCreateFirewallFwsetV1200Response, *http.Response, error) {
// 	return r.ApiService.PostCreateFirewallFwsetV1Execute(r)
// }

// /*
// PostCreateFirewallFwsetV1 V1 Create firewall FwSet

// Create a new firewall FwSet for fast rule matching

//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @return ApiPostCreateFirewallFwsetV1Request
// */
// func (api *FirewallApiService) PostCreateFirewallFwsetV1(ctx context.Context) ApiPostCreateFirewallFwsetV1Request {
// 	return ApiPostCreateFirewallFwsetV1Request{
// 		ApiService: api,
// 		ctx: ctx,
// 	}
// }

// // Execute executes the request
// //  @return PostCreateFirewallFwsetV1200Response
// func (api *FirewallApiService) PostCreateFirewallFwsetV1Execute(r ApiPostCreateFirewallFwsetV1Request) (*PostCreateFirewallFwsetV1200Response, *http.Response, error) {
// 	var (
// 		localVarHTTPMethod   = http.MethodPost
// 		localVarPostBody     interface{}
// 		formFiles            []formFile
// 		localVarReturnValue  *PostCreateFirewallFwsetV1200Response
// 	)

// 	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.PostCreateFirewallFwsetV1")
// 	if err != nil {
// 		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
// 	}

// 	localVarPath := localBasePath + "/firewall/fwsets"

// 	localVarHeaderParams := make(map[string]string)
// 	localVarQueryParams := url.Values{}
// 	localVarFormParams := url.Values{}
// 	if r.createFwsetRequest == nil {
// 		return localVarReturnValue, nil, reportError("createFwsetRequest is required and must be specified")
// 	}

// 	// to determine the Content-Type header
// 	localVarHTTPContentTypes := []string{"application/json"}

// 	// set Content-Type header
// 	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
// 	if localVarHTTPContentType != "" {
// 		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
// 	}

// 	// to determine the Accept header
// 	localVarHTTPHeaderAccepts := []string{"application/json"}

// 	// set Accept header
// 	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
// 	if localVarHTTPHeaderAccept != "" {
// 		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
// 	}
// 	// body params
// 	localVarPostBody = r.createFwsetRequest
// 	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
// 	if err != nil {
// 		return localVarReturnValue, nil, err
// 	}

// 	localVarHTTPResponse, err := api.client.callAPI(req)
// 	if err != nil || localVarHTTPResponse == nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
// 	localVarHTTPResponse.Body.Close()
// 	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
// 	if err != nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	if localVarHTTPResponse.StatusCode >= 300 {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: localVarHTTPResponse.Status,
// 		}
// 		if localVarHTTPResponse.StatusCode == 400 {
// 			var v m.ErrorResponse
// 			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 			newErr.model = v
// 			return localVarReturnValue, localVarHTTPResponse, newErr
// 		}
// 		if localVarHTTPResponse.StatusCode == 403 {
// 			var v m.ErrorResponse
// 			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 			newErr.model = v
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 	if err != nil {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: err.Error(),
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	return localVarReturnValue, localVarHTTPResponse, nil
// }


// type ApiPostCreateFirewallRuleV1Request struct {
// 	ctx context.Context
// 	ApiService *FirewallApiService
// 	createFirewallRuleRequest *CreateFirewallRuleRequest // wrong model now
// }

// func (r ApiPostCreateFirewallRuleV1Request) CreateFirewallRuleRequest(createFirewallRuleRequest CreateFirewallRuleRequest) ApiPostCreateFirewallRuleV1Request {
// 	r.createFirewallRuleRequest = &createFirewallRuleRequest
// 	return r
// }

// func (r ApiPostCreateFirewallRuleV1Request) Execute() (*FirewallRuleOperationResponse, *http.Response, error) {
// 	return r.ApiService.PostCreateFirewallRuleV1Execute(r)
// }

// /*
// PostCreateFirewallRuleV1 V1 Create firewall rule

// V1 API. Adds a firewall rule to the VNS3 Controller's firewall. We recommend using v2/firewall/rules endpoints.

//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @return ApiPostCreateFirewallRuleV1Request
// */
// func (api *FirewallApiService) PostCreateFirewallRuleV1(ctx context.Context) ApiPostCreateFirewallRuleV1Request {
// 	return ApiPostCreateFirewallRuleV1Request{
// 		ApiService: api,
// 		ctx: ctx,
// 	}
// }

// // Execute executes the request
// //  @return FirewallRuleOperationResponse
// func (api *FirewallApiService) PostCreateFirewallRuleV1Execute(r ApiPostCreateFirewallRuleV1Request) (*FirewallRuleOperationResponse, *http.Response, error) {
// 	var (
// 		localVarHTTPMethod   = http.MethodPost
// 		localVarPostBody     interface{}
// 		formFiles            []formFile
// 		localVarReturnValue  *FirewallRuleOperationResponse
// 	)

// 	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.PostCreateFirewallRuleV1")
// 	if err != nil {
// 		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
// 	}

// 	localVarPath := localBasePath + "/firewall/rules"

// 	localVarHeaderParams := make(map[string]string)
// 	localVarQueryParams := url.Values{}
// 	localVarFormParams := url.Values{}
// 	if r.createFirewallRuleRequest == nil {
// 		return localVarReturnValue, nil, reportError("createFirewallRuleRequest is required and must be specified")
// 	}

// 	// to determine the Content-Type header
// 	localVarHTTPContentTypes := []string{"application/json"}

// 	// set Content-Type header
// 	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
// 	if localVarHTTPContentType != "" {
// 		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
// 	}

// 	// to determine the Accept header
// 	localVarHTTPHeaderAccepts := []string{"application/json"}

// 	// set Accept header
// 	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
// 	if localVarHTTPHeaderAccept != "" {
// 		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
// 	}
// 	// body params
// 	localVarPostBody = r.createFirewallRuleRequest
// 	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
// 	if err != nil {
// 		return localVarReturnValue, nil, err
// 	}

// 	localVarHTTPResponse, err := api.client.callAPI(req)
// 	if err != nil || localVarHTTPResponse == nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
// 	localVarHTTPResponse.Body.Close()
// 	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
// 	if err != nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	if localVarHTTPResponse.StatusCode >= 300 {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: localVarHTTPResponse.Status,
// 		}
// 		if localVarHTTPResponse.StatusCode == 400 {
// 			var v m.ErrorResponse
// 			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 			newErr.model = v
// 			return localVarReturnValue, localVarHTTPResponse, newErr
// 		}
// 		if localVarHTTPResponse.StatusCode == 403 {
// 			var v m.ErrorResponse
// 			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 			newErr.model = v
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 	if err != nil {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: err.Error(),
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	return localVarReturnValue, localVarHTTPResponse, nil
// }

// type ApiPostCreateFirewallSubgroupV1Request struct {
// 	ctx context.Context
// 	ApiService *FirewallApiService
// 	createSubgroupRequest *CreateSubgroupRequest
// }

// func (r ApiPostCreateFirewallSubgroupV1Request) CreateSubgroupRequest(createSubgroupRequest CreateSubgroupRequest) ApiPostCreateFirewallSubgroupV1Request {
// 	r.createSubgroupRequest = &createSubgroupRequest
// 	return r
// }

// func (r ApiPostCreateFirewallSubgroupV1Request) Execute() (*PostCreateFirewallSubgroupV1200Response, *http.Response, error) {
// 	return r.ApiService.PostCreateFirewallSubgroupV1Execute(r)
// }

// /*
// PostCreateFirewallSubgroupV1 V1 Create firewall subgroup

// Create a new firewall subgroup. Subgroups are named lists of rules that can be "jumped to" from  another rule. These are effectively IPtables custom chains. For example, PREROUTING_CUST -s 10.0.2.0/24 -j PRE_C_MYGROUP. We recommend using v2/firewall/subtables endpoints.


//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @return ApiPostCreateFirewallSubgroupV1Request
// */
// func (api *FirewallApiService) PostCreateFirewallSubgroupV1(ctx context.Context) ApiPostCreateFirewallSubgroupV1Request {
// 	return ApiPostCreateFirewallSubgroupV1Request{
// 		ApiService: api,
// 		ctx: ctx,
// 	}
// }

// // Execute executes the request
// //  @return PostCreateFirewallSubgroupV1200Response
// func (api *FirewallApiService) PostCreateFirewallSubgroupV1Execute(r ApiPostCreateFirewallSubgroupV1Request) (*PostCreateFirewallSubgroupV1200Response, *http.Response, error) {
// 	var (
// 		localVarHTTPMethod   = http.MethodPost
// 		localVarPostBody     interface{}
// 		formFiles            []formFile
// 		localVarReturnValue  *PostCreateFirewallSubgroupV1200Response
// 	)

// 	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.PostCreateFirewallSubgroupV1")
// 	if err != nil {
// 		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
// 	}

// 	localVarPath := localBasePath + "/firewall/rules/subgroup"

// 	localVarHeaderParams := make(map[string]string)
// 	localVarQueryParams := url.Values{}
// 	localVarFormParams := url.Values{}
// 	if r.createSubgroupRequest == nil {
// 		return localVarReturnValue, nil, reportError("createSubgroupRequest is required and must be specified")
// 	}

// 	// to determine the Content-Type header
// 	localVarHTTPContentTypes := []string{"application/json"}

// 	// set Content-Type header
// 	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
// 	if localVarHTTPContentType != "" {
// 		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
// 	}

// 	// to determine the Accept header
// 	localVarHTTPHeaderAccepts := []string{"application/json"}

// 	// set Accept header
// 	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
// 	if localVarHTTPHeaderAccept != "" {
// 		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
// 	}
// 	// body params
// 	localVarPostBody = r.createSubgroupRequest
// 	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
// 	if err != nil {
// 		return localVarReturnValue, nil, err
// 	}

// 	localVarHTTPResponse, err := api.client.callAPI(req)
// 	if err != nil || localVarHTTPResponse == nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
// 	localVarHTTPResponse.Body.Close()
// 	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
// 	if err != nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	if localVarHTTPResponse.StatusCode >= 300 {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: localVarHTTPResponse.Status,
// 		}
// 		if localVarHTTPResponse.StatusCode == 400 {
// 			var v m.ErrorResponse
// 			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 			newErr.model = v
// 			return localVarReturnValue, localVarHTTPResponse, newErr
// 		}
// 		if localVarHTTPResponse.StatusCode == 403 {
// 			var v m.ErrorResponse
// 			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 			newErr.model = v
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 	if err != nil {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: err.Error(),
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	return localVarReturnValue, localVarHTTPResponse, nil
// }


// type ApiPutFirewallActionV1Request struct {
// 	ctx context.Context
// 	ApiService *FirewallApiService
// 	firewallActionRequest *FirewallActionRequest
// }

// func (r ApiPutFirewallActionV1Request) FirewallActionRequest(firewallActionRequest FirewallActionRequest) ApiPutFirewallActionV1Request {
// 	r.firewallActionRequest = &firewallActionRequest
// 	return r
// }

// func (r ApiPutFirewallActionV1Request) Execute() (*Object, *http.Response, error) {
// 	return r.ApiService.PutFirewallActionV1Execute(r)
// }

// /*
// PutFirewallActionV1 V1 Put firewall action

// Take an action on the firewall

//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @return ApiPutFirewallActionV1Request
// */
// func (api *FirewallApiService) PutFirewallActionV1(ctx context.Context) ApiPutFirewallActionV1Request {
// 	return ApiPutFirewallActionV1Request{
// 		ApiService: api,
// 		ctx: ctx,
// 	}
// }

// // Execute executes the request
// //  @return Object
// func (api *FirewallApiService) PutFirewallActionV1Execute(r ApiPutFirewallActionV1Request) (*Object, *http.Response, error) {
// 	var (
// 		localVarHTTPMethod   = http.MethodPut
// 		localVarPostBody     interface{}
// 		formFiles            []formFile
// 		localVarReturnValue  *Object
// 	)

// 	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.PutFirewallActionV1")
// 	if err != nil {
// 		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
// 	}

// 	localVarPath := localBasePath + "/firewall/actions"

// 	localVarHeaderParams := make(map[string]string)
// 	localVarQueryParams := url.Values{}
// 	localVarFormParams := url.Values{}
// 	if r.firewallActionRequest == nil {
// 		return localVarReturnValue, nil, reportError("firewallActionRequest is required and must be specified")
// 	}

// 	// to determine the Content-Type header
// 	localVarHTTPContentTypes := []string{"application/json"}

// 	// set Content-Type header
// 	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
// 	if localVarHTTPContentType != "" {
// 		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
// 	}

// 	// to determine the Accept header
// 	localVarHTTPHeaderAccepts := []string{"application/json"}

// 	// set Accept header
// 	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
// 	if localVarHTTPHeaderAccept != "" {
// 		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
// 	}
// 	// body params
// 	localVarPostBody = r.firewallActionRequest
// 	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
// 	if err != nil {
// 		return localVarReturnValue, nil, err
// 	}

// 	localVarHTTPResponse, err := api.client.callAPI(req)
// 	if err != nil || localVarHTTPResponse == nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
// 	localVarHTTPResponse.Body.Close()
// 	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
// 	if err != nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	if localVarHTTPResponse.StatusCode >= 300 {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: localVarHTTPResponse.Status,
// 		}
// 		if localVarHTTPResponse.StatusCode == 403 {
// 			var v m.ErrorResponse
// 			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 			newErr.model = v
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 	if err != nil {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: err.Error(),
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	return localVarReturnValue, localVarHTTPResponse, nil
// }

// type ApiPutOverwriteFirewallV1Request struct {
// 	ctx context.Context
// 	ApiService *FirewallApiService
// 	overwriteRequest *OverwriteRequest
// }

// func (r ApiPutOverwriteFirewallV1Request) OverwriteRequest(overwriteRequest OverwriteRequest) ApiPutOverwriteFirewallV1Request {
// 	r.overwriteRequest = &overwriteRequest
// 	return r
// }

// func (r ApiPutOverwriteFirewallV1Request) Execute() (*TaskTokenResponse, *http.Response, error) {
// 	return r.ApiService.PutOverwriteFirewallV1Execute(r)
// }

// /*
// PutOverwriteFirewallV1 V1 Put firewall

// V1 API. Put/Overwrite entire firewall. Careful! We recommend using v2/firewall endpoints.

//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @return ApiPutOverwriteFirewallV1Request
// */
// func (api *FirewallApiService) PutOverwriteFirewallV1(ctx context.Context) ApiPutOverwriteFirewallV1Request {
// 	return ApiPutOverwriteFirewallV1Request{
// 		ApiService: api,
// 		ctx: ctx,
// 	}
// }

// // Execute executes the request
// //  @return TaskTokenResponse
// func (api *FirewallApiService) PutOverwriteFirewallV1Execute(r ApiPutOverwriteFirewallV1Request) (*TaskTokenResponse, *http.Response, error) {
// 	var (
// 		localVarHTTPMethod   = http.MethodPut
// 		localVarPostBody     interface{}
// 		formFiles            []formFile
// 		localVarReturnValue  *TaskTokenResponse
// 	)

// 	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.PutOverwriteFirewallV1")
// 	if err != nil {
// 		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
// 	}

// 	localVarPath := localBasePath + "/firewall"

// 	localVarHeaderParams := make(map[string]string)
// 	localVarQueryParams := url.Values{}
// 	localVarFormParams := url.Values{}
// 	if r.overwriteRequest == nil {
// 		return localVarReturnValue, nil, reportError("overwriteRequest is required and must be specified")
// 	}

// 	// to determine the Content-Type header
// 	localVarHTTPContentTypes := []string{"application/json"}

// 	// set Content-Type header
// 	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
// 	if localVarHTTPContentType != "" {
// 		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
// 	}

// 	// to determine the Accept header
// 	localVarHTTPHeaderAccepts := []string{"application/json"}

// 	// set Accept header
// 	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
// 	if localVarHTTPHeaderAccept != "" {
// 		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
// 	}
// 	// body params
// 	localVarPostBody = r.overwriteRequest
// 	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
// 	if err != nil {
// 		return localVarReturnValue, nil, err
// 	}

// 	localVarHTTPResponse, err := api.client.callAPI(req)
// 	if err != nil || localVarHTTPResponse == nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
// 	localVarHTTPResponse.Body.Close()
// 	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
// 	if err != nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	if localVarHTTPResponse.StatusCode >= 300 {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: localVarHTTPResponse.Status,
// 		}
// 		if localVarHTTPResponse.StatusCode == 403 {
// 			var v m.ErrorResponse
// 			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 			newErr.model = v
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 	if err != nil {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: err.Error(),
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	return localVarReturnValue, localVarHTTPResponse, nil
// }

// type ApiPutReinitializeFirewallSubgroupsV1Request struct {
// 	ctx context.Context
// 	ApiService *FirewallApiService
// 	reinitRequest *ReinitRequest
// }

// func (r ApiPutReinitializeFirewallSubgroupsV1Request) ReinitRequest(reinitRequest ReinitRequest) ApiPutReinitializeFirewallSubgroupsV1Request {
// 	r.reinitRequest = &reinitRequest
// 	return r
// }

// func (r ApiPutReinitializeFirewallSubgroupsV1Request) Execute() (*http.Response, error) {
// 	return r.ApiService.PutReinitializeFirewallSubgroupsV1Execute(r)
// }

// /*
// PutReinitializeFirewallSubgroupsV1 V1 Reload firewall subgroups

// V1 API. Reload firewall subgroups. We recommend using v2/firewall/subtables endpoints.

//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @return ApiPutReinitializeFirewallSubgroupsV1Request
// */
// func (api *FirewallApiService) PutReinitializeFirewallSubgroupsV1(ctx context.Context) ApiPutReinitializeFirewallSubgroupsV1Request {
// 	return ApiPutReinitializeFirewallSubgroupsV1Request{
// 		ApiService: api,
// 		ctx: ctx,
// 	}
// }

// // Execute executes the request
// func (api *FirewallApiService) PutReinitializeFirewallSubgroupsV1Execute(r ApiPutReinitializeFirewallSubgroupsV1Request) (*http.Response, error) {
// 	var (
// 		localVarHTTPMethod   = http.MethodPut
// 		localVarPostBody     interface{}
// 		formFiles            []formFile
// 	)

// 	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.PutReinitializeFirewallSubgroupsV1")
// 	if err != nil {
// 		return nil, &GenericOpenAPIError{error: err.Error()}
// 	}

// 	localVarPath := localBasePath + "/firewall/rules/subgroup"

// 	localVarHeaderParams := make(map[string]string)
// 	localVarQueryParams := url.Values{}
// 	localVarFormParams := url.Values{}
// 	if r.reinitRequest == nil {
// 		return nil, reportError("reinitRequest is required and must be specified")
// 	}

// 	// to determine the Content-Type header
// 	localVarHTTPContentTypes := []string{"application/json"}

// 	// set Content-Type header
// 	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
// 	if localVarHTTPContentType != "" {
// 		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
// 	}

// 	// to determine the Accept header
// 	localVarHTTPHeaderAccepts := []string{"application/json"}

// 	// set Accept header
// 	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
// 	if localVarHTTPHeaderAccept != "" {
// 		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
// 	}
// 	// body params
// 	localVarPostBody = r.reinitRequest
// 	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
// 	if err != nil {
// 		return nil, err
// 	}

// 	localVarHTTPResponse, err := api.client.callAPI(req)
// 	if err != nil || localVarHTTPResponse == nil {
// 		return localVarHTTPResponse, err
// 	}

// 	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
// 	localVarHTTPResponse.Body.Close()
// 	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
// 	if err != nil {
// 		return localVarHTTPResponse, err
// 	}

// 	if localVarHTTPResponse.StatusCode >= 300 {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: localVarHTTPResponse.Status,
// 		}
// 		if localVarHTTPResponse.StatusCode == 403 {
// 			var v m.ErrorResponse
// 			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarHTTPResponse, newErr
// 			}
// 			newErr.model = v
// 		}
// 		return localVarHTTPResponse, newErr
// 	}

// 	return localVarHTTPResponse, nil
// }

// type ApiPutReinitializeFwsetsV1Request struct {
// 	ctx context.Context
// 	ApiService *FirewallApiService
// 	reinitRequest *ReinitRequest
// }

// func (r ApiPutReinitializeFwsetsV1Request) ReinitRequest(reinitRequest ReinitRequest) ApiPutReinitializeFwsetsV1Request {
// 	r.reinitRequest = &reinitRequest
// 	return r
// }

// func (r ApiPutReinitializeFwsetsV1Request) Execute() (*http.Response, error) {
// 	return r.ApiService.PutReinitializeFwsetsV1Execute(r)
// }

// /*
// PutReinitializeFwsetsV1 V1 Reload all firewall Fwsets

// Reload all firewall Fwsets

//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @return ApiPutReinitializeFwsetsV1Request
// */
// func (api *FirewallApiService) PutReinitializeFwsetsV1(ctx context.Context) ApiPutReinitializeFwsetsV1Request {
// 	return ApiPutReinitializeFwsetsV1Request{
// 		ApiService: api,
// 		ctx: ctx,
// 	}
// }

// // Execute executes the request
// func (api *FirewallApiService) PutReinitializeFwsetsV1Execute(r ApiPutReinitializeFwsetsV1Request) (*http.Response, error) {
// 	var (
// 		localVarHTTPMethod   = http.MethodPut
// 		localVarPostBody     interface{}
// 		formFiles            []formFile
// 	)

// 	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "FirewallApiService.PutReinitializeFwsetsV1")
// 	if err != nil {
// 		return nil, &GenericOpenAPIError{error: err.Error()}
// 	}

// 	localVarPath := localBasePath + "/firewall/fwsets"

// 	localVarHeaderParams := make(map[string]string)
// 	localVarQueryParams := url.Values{}
// 	localVarFormParams := url.Values{}
// 	if r.reinitRequest == nil {
// 		return nil, reportError("reinitRequest is required and must be specified")
// 	}

// 	// to determine the Content-Type header
// 	localVarHTTPContentTypes := []string{"application/json"}

// 	// set Content-Type header
// 	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
// 	if localVarHTTPContentType != "" {
// 		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
// 	}

// 	// to determine the Accept header
// 	localVarHTTPHeaderAccepts := []string{"application/json"}

// 	// set Accept header
// 	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
// 	if localVarHTTPHeaderAccept != "" {
// 		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
// 	}
// 	// body params
// 	localVarPostBody = r.reinitRequest
// 	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
// 	if err != nil {
// 		return nil, err
// 	}

// 	localVarHTTPResponse, err := api.client.callAPI(req)
// 	if err != nil || localVarHTTPResponse == nil {
// 		return localVarHTTPResponse, err
// 	}

// 	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
// 	localVarHTTPResponse.Body.Close()
// 	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
// 	if err != nil {
// 		return localVarHTTPResponse, err
// 	}

// 	if localVarHTTPResponse.StatusCode >= 300 {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: localVarHTTPResponse.Status,
// 		}
// 		if localVarHTTPResponse.StatusCode == 403 {
// 			var v m.ErrorResponse
// 			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarHTTPResponse, newErr
// 			}
// 			newErr.model = v
// 		}
// 		return localVarHTTPResponse, newErr
// 	}

// 	return localVarHTTPResponse, nil
// }
