/*
VNS3 Controller API

Cohesive networks VNS3 provides complete control of your network's addressing, routes, rules and edge enabling a secure, connected and reactive cloud network. 

API version: 6.0.0
Contact: support@cohesive.net
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cohesivenet

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	m "cohesivenet/models"
)


// IpsecApiService IPsecApi service
type IpsecApiService service

type ApiDeleteIpsecEndpointRequest struct {
	ctx context.Context
	ApiService *IpsecApiService
	endpointId int32
}

func (r ApiDeleteIpsecEndpointRequest) Execute() (*m.IpsecSystemDetailResponse, *http.Response, error) {
	return r.ApiService.DeleteIpsecEndpointExecute(r)
}

/*
DeleteIpsecEndpoint Delete IPsec endpoint

Delete IPsec endpoint

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointId ID for IPsec endpoint
 @return ApiDeleteIpsecEndpointRequest
*/
func (api *IpsecApiService) DeleteIpsecEndpoint(ctx context.Context, endpointId int32) ApiDeleteIpsecEndpointRequest {
	return ApiDeleteIpsecEndpointRequest{
		ApiService: api,
		ctx: ctx,
		endpointId: endpointId,
	}
}

// Execute executes the request
//  @return m.IpsecSystemDetailResponse
func (api *IpsecApiService) DeleteIpsecEndpointExecute(r ApiDeleteIpsecEndpointRequest) (*m.IpsecSystemDetailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.IpsecSystemDetailResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "IpsecApiService.DeleteIpsecEndpoint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipsec/endpoints/{endpoint_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"endpoint_id"+"}", url.PathEscape(parameterToString(r.endpointId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.endpointId < 1 {
		return localVarReturnValue, nil, reportError("endpointId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteIpsecEndpointTunnelRequest struct {
	ctx context.Context
	ApiService *IpsecApiService
	endpointId int32
	tunnelId int32
}

func (r ApiDeleteIpsecEndpointTunnelRequest) Execute() (*m.IpsecRemoteEndpointDetail, *http.Response, error) {
	return r.ApiService.DeleteIpsecEndpointTunnelExecute(r)
}

/*
DeleteIpsecEndpointTunnel Delete IPsec tunnel

Delete IPsec tunnel

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointId ID for IPsec endpoint
 @param tunnelId ID for tunnel
 @return ApiDeleteIpsecEndpointTunnelRequest
*/
func (api *IpsecApiService) DeleteIpsecEndpointTunnel(ctx context.Context, endpointId int32, tunnelId int32) ApiDeleteIpsecEndpointTunnelRequest {
	return ApiDeleteIpsecEndpointTunnelRequest{
		ApiService: api,
		ctx: ctx,
		endpointId: endpointId,
		tunnelId: tunnelId,
	}
}

// Execute executes the request
//  @return m.IpsecRemoteEndpointDetail
func (api *IpsecApiService) DeleteIpsecEndpointTunnelExecute(r ApiDeleteIpsecEndpointTunnelRequest) (*m.IpsecRemoteEndpointDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.IpsecRemoteEndpointDetail
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "IpsecApiService.DeleteIpsecEndpointTunnel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipsec/endpoints/{endpoint_id}/tunnels/{tunnel_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"endpoint_id"+"}", url.PathEscape(parameterToString(r.endpointId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tunnel_id"+"}", url.PathEscape(parameterToString(r.tunnelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.endpointId < 1 {
		return localVarReturnValue, nil, reportError("endpointId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteIpsecTrafficPairRequest struct {
	ctx context.Context
	ApiService *IpsecApiService
	endpointId int32
	pairId int32
}

func (r ApiDeleteIpsecTrafficPairRequest) Execute() (*m.IpsecTrafficPairResponse, *http.Response, error) {
	return r.ApiService.DeleteIpsecTrafficPairExecute(r)
}

/*
DeleteIpsecTrafficPair Delete IPsec traffic pair

Delete IPsec traffic pair

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointId ID for IPsec endpoint
 @param pairId ID for traffic pair
 @return ApiDeleteIpsecTrafficPairRequest
*/
func (api *IpsecApiService) DeleteIpsecTrafficPair(ctx context.Context, endpointId int32, pairId int32) ApiDeleteIpsecTrafficPairRequest {
	return ApiDeleteIpsecTrafficPairRequest{
		ApiService: api,
		ctx: ctx,
		endpointId: endpointId,
		pairId: pairId,
	}
}

// Execute executes the request
//  @return m.IpsecTrafficPairResponse
func (api *IpsecApiService) DeleteIpsecTrafficPairExecute(r ApiDeleteIpsecTrafficPairRequest) (*m.IpsecTrafficPairResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.IpsecTrafficPairResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "IpsecApiService.DeleteIpsecTrafficPair")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipsec/endpoints/{endpoint_id}/traffic_pairs/{pair_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"endpoint_id"+"}", url.PathEscape(parameterToString(r.endpointId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pair_id"+"}", url.PathEscape(parameterToString(r.pairId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.endpointId < 1 {
		return localVarReturnValue, nil, reportError("endpointId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDisableIpsecTrafficPairRequest struct {
	ctx context.Context
	ApiService *IpsecApiService
	endpointId int32
	pairId int32
}

func (r ApiDisableIpsecTrafficPairRequest) Execute() (*m.IpsecTrafficPairResponse, *http.Response, error) {
	return r.ApiService.DisableIpsecTrafficPairExecute(r)
}

/*
DisableIpsecTrafficPair Disable IPsec traffic pair

Disable Ipsec Traffic Pair

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointId ID for IPsec endpoint
 @param pairId ID for traffic pair
 @return ApiDisableIpsecTrafficPairRequest
*/
func (api *IpsecApiService) DisableIpsecTrafficPair(ctx context.Context, endpointId int32, pairId int32) ApiDisableIpsecTrafficPairRequest {
	return ApiDisableIpsecTrafficPairRequest{
		ApiService: api,
		ctx: ctx,
		endpointId: endpointId,
		pairId: pairId,
	}
}

// Execute executes the request
//  @return m.IpsecTrafficPairResponse
func (api *IpsecApiService) DisableIpsecTrafficPairExecute(r ApiDisableIpsecTrafficPairRequest) (*m.IpsecTrafficPairResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.IpsecTrafficPairResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "IpsecApiService.DisableIpsecTrafficPair")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipsec/endpoints/{endpoint_id}/traffic_pairs/{pair_id}/disable"
	localVarPath = strings.Replace(localVarPath, "{"+"endpoint_id"+"}", url.PathEscape(parameterToString(r.endpointId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pair_id"+"}", url.PathEscape(parameterToString(r.pairId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.endpointId < 1 {
		return localVarReturnValue, nil, reportError("endpointId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnableIpsecTrafficPairRequest struct {
	ctx context.Context
	ApiService *IpsecApiService
	endpointId int32
	pairId int32
}

func (r ApiEnableIpsecTrafficPairRequest) Execute() (*m.IpsecTrafficPairResponse, *http.Response, error) {
	return r.ApiService.EnableIpsecTrafficPairExecute(r)
}

/*
EnableIpsecTrafficPair Enable IPsec traffic pair

Enable Ipsec Traffic Pair

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointId ID for IPsec endpoint
 @param pairId ID for traffic pair
 @return ApiEnableIpsecTrafficPairRequest
*/
func (api *IpsecApiService) EnableIpsecTrafficPair(ctx context.Context, endpointId int32, pairId int32) ApiEnableIpsecTrafficPairRequest {
	return ApiEnableIpsecTrafficPairRequest{
		ApiService: api,
		ctx: ctx,
		endpointId: endpointId,
		pairId: pairId,
	}
}

// Execute executes the request
//  @return m.IpsecTrafficPairResponse
func (api *IpsecApiService) EnableIpsecTrafficPairExecute(r ApiEnableIpsecTrafficPairRequest) (*m.IpsecTrafficPairResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.IpsecTrafficPairResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "IpsecApiService.EnableIpsecTrafficPair")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipsec/endpoints/{endpoint_id}/traffic_pairs/{pair_id}/enable"
	localVarPath = strings.Replace(localVarPath, "{"+"endpoint_id"+"}", url.PathEscape(parameterToString(r.endpointId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pair_id"+"}", url.PathEscape(parameterToString(r.pairId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.endpointId < 1 {
		return localVarReturnValue, nil, reportError("endpointId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConnectedSubnetsRequest struct {
	ctx context.Context
	ApiService *IpsecApiService
	extendedOutput *bool
}

// Receive verbose information about resources
func (r ApiGetConnectedSubnetsRequest) ExtendedOutput(extendedOutput bool) ApiGetConnectedSubnetsRequest {
	r.extendedOutput = &extendedOutput
	return r
}

func (r ApiGetConnectedSubnetsRequest) Execute() (*m.ConnectedSubnetsDetailResponse, *http.Response, error) {
	return r.ApiService.GetConnectedSubnetsExecute(r)
}

/*
GetConnectedSubnets Get connected subnets

Provides information about any connected subnets.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetConnectedSubnetsRequest
*/
func (api *IpsecApiService) GetConnectedSubnets(ctx context.Context) ApiGetConnectedSubnetsRequest {
	return ApiGetConnectedSubnetsRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return m.ConnectedSubnetsDetailResponse
func (api *IpsecApiService) GetConnectedSubnetsExecute(r ApiGetConnectedSubnetsRequest) (*m.ConnectedSubnetsDetailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.ConnectedSubnetsDetailResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "IpsecApiService.GetConnectedSubnets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/status/connected_subnets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.extendedOutput != nil {
		localVarQueryParams.Add("extended_output", parameterToString(*r.extendedOutput, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIpsecDetailsRequest struct {
	ctx context.Context
	ApiService *IpsecApiService
}

func (r ApiGetIpsecDetailsRequest) Execute() (*m.IpsecSystemDetailResponse, *http.Response, error) {
	return r.ApiService.GetIpsecDetailsExecute(r)
}

/*
GetIpsecDetails Get IPsec details

Get details for all IPsec endpoints/subnets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIpsecDetailsRequest
*/
func (api *IpsecApiService) GetIpsecDetails(ctx context.Context) ApiGetIpsecDetailsRequest {
	return ApiGetIpsecDetailsRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return m.IpsecSystemDetailResponse
func (api *IpsecApiService) GetIpsecDetailsExecute(r ApiGetIpsecDetailsRequest) (*m.IpsecSystemDetailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.IpsecSystemDetailResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "IpsecApiService.GetIpsecDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipsec"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIpsecEndpointRequest struct {
	ctx context.Context
	ApiService *IpsecApiService
	endpointId int32
}

func (r ApiGetIpsecEndpointRequest) Execute() (*m.IpsecRemoteEndpointDetail, *http.Response, error) {
	return r.ApiService.GetIpsecEndpointExecute(r)
}

/*
GetIpsecEndpoint Get IPsec endpoint

Get IPsec endpoint information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointId ID for IPsec endpoint
 @return ApiGetIpsecEndpointRequest
*/
func (api *IpsecApiService) GetIpsecEndpoint(ctx context.Context, endpointId int32) ApiGetIpsecEndpointRequest {
	return ApiGetIpsecEndpointRequest{
		ApiService: api,
		ctx: ctx,
		endpointId: endpointId,
	}
}

// Execute executes the request
//  @return m.IpsecRemoteEndpointDetail
func (api *IpsecApiService) GetIpsecEndpointExecute(r ApiGetIpsecEndpointRequest) (*m.IpsecRemoteEndpointDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.IpsecRemoteEndpointDetail
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "IpsecApiService.GetIpsecEndpoint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipsec/endpoints/{endpoint_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"endpoint_id"+"}", url.PathEscape(parameterToString(r.endpointId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.endpointId < 1 {
		return localVarReturnValue, nil, reportError("endpointId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIpsecLinkHistoryRequest struct {
	ctx context.Context
	ApiService *IpsecApiService
	remote *string
	local *string
	tunnelid *int32
}

// Address string in CIDR format to display link history to a remote endpoint.
func (r ApiGetIpsecLinkHistoryRequest) Remote(remote string) ApiGetIpsecLinkHistoryRequest {
	r.remote = &remote
	return r
}

// Address string in CIDR format which will display status of the local route
func (r ApiGetIpsecLinkHistoryRequest) Local(local string) ApiGetIpsecLinkHistoryRequest {
	r.local = &local
	return r
}

// Will display link history of just the tunnel specified, which may be only one tunnel to a remote endpoint.
func (r ApiGetIpsecLinkHistoryRequest) Tunnelid(tunnelid int32) ApiGetIpsecLinkHistoryRequest {
	r.tunnelid = &tunnelid
	return r
}

func (r ApiGetIpsecLinkHistoryRequest) Execute() (*m.LinkHistoryDetail, *http.Response, error) {
	return r.ApiService.GetIpsecLinkHistoryExecute(r)
}

/*
GetIpsecLinkHistory Get IPsec link history

Provides information about the connection history of the subnet or tunnel

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIpsecLinkHistoryRequest
*/
func (api *IpsecApiService) GetIpsecLinkHistory(ctx context.Context) ApiGetIpsecLinkHistoryRequest {
	return ApiGetIpsecLinkHistoryRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return m.LinkHistoryDetail
func (api *IpsecApiService) GetIpsecLinkHistoryExecute(r ApiGetIpsecLinkHistoryRequest) (*m.LinkHistoryDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.LinkHistoryDetail
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "IpsecApiService.GetIpsecLinkHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/status/link_history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.remote != nil {
		localVarQueryParams.Add("remote", parameterToString(*r.remote, ""))
	}
	if r.local != nil {
		localVarQueryParams.Add("local", parameterToString(*r.local, ""))
	}
	if r.tunnelid != nil {
		localVarQueryParams.Add("tunnelid", parameterToString(*r.tunnelid, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIpsecStatusRequest struct {
	ctx context.Context
	ApiService *IpsecApiService
	upDownStatusOnly *bool
}

// Only retrieve tunnel status. True is more performant but has less info. Defaults to false.
func (r ApiGetIpsecStatusRequest) UpDownStatusOnly(upDownStatusOnly bool) ApiGetIpsecStatusRequest {
	r.upDownStatusOnly = &upDownStatusOnly
	return r
}

func (r ApiGetIpsecStatusRequest) Execute() (*m.IpsecTunnelListResponseAsObject, *http.Response, error) {
	return r.ApiService.GetIpsecStatusExecute(r)
}

/*
GetIpsecStatus Get IPsec status

Describe ipsec tunnels status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetIpsecStatusRequest
*/
func (api *IpsecApiService) GetIpsecStatus(ctx context.Context) ApiGetIpsecStatusRequest {
	return ApiGetIpsecStatusRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return m.IpsecTunnelListResponseAsObject
func (api *IpsecApiService) GetIpsecStatusExecute(r ApiGetIpsecStatusRequest) (*m.IpsecTunnelListResponseAsObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.IpsecTunnelListResponseAsObject
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "IpsecApiService.GetIpsecStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/status/ipsec"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.upDownStatusOnly != nil {
		localVarQueryParams.Add("up_down_status_only", parameterToString(*r.upDownStatusOnly, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCreateIpsecEndpointRequest struct {
	ctx context.Context
	ApiService *IpsecApiService
	createIpsecEndpointRequest *m.CreateIpsecEndpointRequest
}

func (r ApiPostCreateIpsecEndpointRequest) CreateIpsecEndpointRequest(createIpsecEndpointRequest m.CreateIpsecEndpointRequest) ApiPostCreateIpsecEndpointRequest {
	r.createIpsecEndpointRequest = &createIpsecEndpointRequest
	return r
}

func (r ApiPostCreateIpsecEndpointRequest) Execute() (*m.IpsecRemoteEndpointDetail, *http.Response, error) {
	return r.ApiService.PostCreateIpsecEndpointExecute(r)
}

/*
PostCreateIpsecEndpoint Create IPsec endpoint

Create IPsec connection to the defined remote gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCreateIpsecEndpointRequest
*/
func (api *IpsecApiService) PostCreateIpsecEndpoint(ctx context.Context) ApiPostCreateIpsecEndpointRequest {
	return ApiPostCreateIpsecEndpointRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return m.IpsecRemoteEndpointDetail
func (api *IpsecApiService) PostCreateIpsecEndpointExecute(r ApiPostCreateIpsecEndpointRequest) (*m.IpsecRemoteEndpointDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.IpsecRemoteEndpointDetail
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "IpsecApiService.PostCreateIpsecEndpoint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipsec/endpoints"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createIpsecEndpointRequest == nil {
		return localVarReturnValue, nil, reportError("createIpsecEndpointRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createIpsecEndpointRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCreateIpsecEndpointTunnelRequest struct {
	ctx context.Context
	ApiService *IpsecApiService
	endpointId int32
	createIpsecTunnelRequest *m.CreateIpsecTunnelRequest
}

func (r ApiPostCreateIpsecEndpointTunnelRequest) CreateIpsecTunnelRequest(createIpsecTunnelRequest m.CreateIpsecTunnelRequest) ApiPostCreateIpsecEndpointTunnelRequest {
	r.createIpsecTunnelRequest = &createIpsecTunnelRequest
	return r
}

func (r ApiPostCreateIpsecEndpointTunnelRequest) Execute() (*m.IpsecRemoteEndpointDetail, *http.Response, error) {
	return r.ApiService.PostCreateIpsecEndpointTunnelExecute(r)
}

/*
PostCreateIpsecEndpointTunnel Create IPsec endpoint tunnel

Create IPsec endpoint tunnel

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointId ID for IPsec endpoint
 @return ApiPostCreateIpsecEndpointTunnelRequest
*/
func (api *IpsecApiService) PostCreateIpsecEndpointTunnel(ctx context.Context, endpointId int32) ApiPostCreateIpsecEndpointTunnelRequest {
	return ApiPostCreateIpsecEndpointTunnelRequest{
		ApiService: api,
		ctx: ctx,
		endpointId: endpointId,
	}
}

// Execute executes the request
//  @return m.IpsecRemoteEndpointDetail
func (api *IpsecApiService) PostCreateIpsecEndpointTunnelExecute(r ApiPostCreateIpsecEndpointTunnelRequest) (*m.IpsecRemoteEndpointDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.IpsecRemoteEndpointDetail
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "IpsecApiService.PostCreateIpsecEndpointTunnel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipsec/endpoints/{endpoint_id}/tunnels"
	localVarPath = strings.Replace(localVarPath, "{"+"endpoint_id"+"}", url.PathEscape(parameterToString(r.endpointId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.endpointId < 1 {
		return localVarReturnValue, nil, reportError("endpointId must be greater than 1")
	}
	if r.createIpsecTunnelRequest == nil {
		return localVarReturnValue, nil, reportError("createIpsecTunnelRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createIpsecTunnelRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCreateIpsecTrafficPairRequest struct {
	ctx context.Context
	ApiService *IpsecApiService
	endpointId int32
	createIpsecTrafficPairRequest *m.CreateIpsecTrafficPairRequest
}

func (r ApiPostCreateIpsecTrafficPairRequest) CreateIpsecTrafficPairRequest(createIpsecTrafficPairRequest m.CreateIpsecTrafficPairRequest) ApiPostCreateIpsecTrafficPairRequest {
	r.createIpsecTrafficPairRequest = &createIpsecTrafficPairRequest
	return r
}

func (r ApiPostCreateIpsecTrafficPairRequest) Execute() (*m.IpsecTrafficPairResponse, *http.Response, error) {
	return r.ApiService.PostCreateIpsecTrafficPairExecute(r)
}

/*
PostCreateIpsecTrafficPair Create IPsec traffic pair

Create IPsec endpoint traffic pair

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointId ID for IPsec endpoint
 @return ApiPostCreateIpsecTrafficPairRequest
*/
func (api *IpsecApiService) PostCreateIpsecTrafficPair(ctx context.Context, endpointId int32) ApiPostCreateIpsecTrafficPairRequest {
	return ApiPostCreateIpsecTrafficPairRequest{
		ApiService: api,
		ctx: ctx,
		endpointId: endpointId,
	}
}

// Execute executes the request
//  @return m.IpsecTrafficPairResponse
func (api *IpsecApiService) PostCreateIpsecTrafficPairExecute(r ApiPostCreateIpsecTrafficPairRequest) (*m.IpsecTrafficPairResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.IpsecTrafficPairResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "IpsecApiService.PostCreateIpsecTrafficPair")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipsec/endpoints/{endpoint_id}/traffic_pairs"
	localVarPath = strings.Replace(localVarPath, "{"+"endpoint_id"+"}", url.PathEscape(parameterToString(r.endpointId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.endpointId < 1 {
		return localVarReturnValue, nil, reportError("endpointId must be greater than 1")
	}
	if r.createIpsecTrafficPairRequest == nil {
		return localVarReturnValue, nil, reportError("createIpsecTrafficPairRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createIpsecTrafficPairRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostRestartIpsecActionRequest struct {
	ctx context.Context
	ApiService *IpsecApiService
	restartRequest *m.RestartRequest
}

func (r ApiPostRestartIpsecActionRequest) RestartRequest(restartRequest m.RestartRequest) ApiPostRestartIpsecActionRequest {
	r.restartRequest = &restartRequest
	return r
}

func (r ApiPostRestartIpsecActionRequest) Execute() (*m.RestartStatusResponse, *http.Response, error) {
	return r.ApiService.PostRestartIpsecActionExecute(r)
}

/*
PostRestartIpsecAction Restart ipsec subystem

Restart ipsec subystem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostRestartIpsecActionRequest
*/
func (api *IpsecApiService) PostRestartIpsecAction(ctx context.Context) ApiPostRestartIpsecActionRequest {
	return ApiPostRestartIpsecActionRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return m.RestartStatusResponse
func (api *IpsecApiService) PostRestartIpsecActionExecute(r ApiPostRestartIpsecActionRequest) (*m.RestartStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.RestartStatusResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "IpsecApiService.PostRestartIpsecAction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipsec"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.restartRequest == nil {
		return localVarReturnValue, nil, reportError("restartRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restartRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutUpdateIpsecConfigRequest struct {
	ctx context.Context
	ApiService *IpsecApiService
	updateIpsecAddressRequest *m.UpdateIpsecAddressRequest
}

func (r ApiPutUpdateIpsecConfigRequest) UpdateIpsecAddressRequest(updateIpsecAddressRequest m.UpdateIpsecAddressRequest) ApiPutUpdateIpsecConfigRequest {
	r.updateIpsecAddressRequest = &updateIpsecAddressRequest
	return r
}

func (r ApiPutUpdateIpsecConfigRequest) Execute() (*m.IpsecSystemDetailResponse, *http.Response, error) {
	return r.ApiService.PutUpdateIpsecConfigExecute(r)
}

/*
PutUpdateIpsecConfig Update IPsec config

Edit Ipsec Configuration on device. Note, This is device wide and must be set before  any remote endpoint definitions are created. If it needs to be changed, all remote endpoint  information and tunnel information must be deleted first.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutUpdateIpsecConfigRequest
*/
func (api *IpsecApiService) PutUpdateIpsecConfig(ctx context.Context) ApiPutUpdateIpsecConfigRequest {
	return ApiPutUpdateIpsecConfigRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return m.IpsecSystemDetailResponse
func (api *IpsecApiService) PutUpdateIpsecConfigExecute(r ApiPutUpdateIpsecConfigRequest) (*m.IpsecSystemDetailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.IpsecSystemDetailResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "IpsecApiService.PutUpdateIpsecConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipsec"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateIpsecAddressRequest == nil {
		return localVarReturnValue, nil, reportError("updateIpsecAddressRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateIpsecAddressRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutUpdateIpsecEndpointRequest struct {
	ctx context.Context
	ApiService *IpsecApiService
	endpointId int32
	updateIpsecEndpointRequest *m.UpdateIpsecEndpointRequest
}

func (r ApiPutUpdateIpsecEndpointRequest) UpdateIpsecEndpointRequest(updateIpsecEndpointRequest m.UpdateIpsecEndpointRequest) ApiPutUpdateIpsecEndpointRequest {
	r.updateIpsecEndpointRequest = &updateIpsecEndpointRequest
	return r
}

func (r ApiPutUpdateIpsecEndpointRequest) Execute() (*m.IpsecRemoteEndpointDetail, *http.Response, error) {
	return r.ApiService.PutUpdateIpsecEndpointExecute(r)
}

/*
PutUpdateIpsecEndpoint Update IPsec endpoint

Edit IPsec endpoint connection configuration parameters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointId ID for IPsec endpoint
 @return ApiPutUpdateIpsecEndpointRequest
*/
func (api *IpsecApiService) PutUpdateIpsecEndpoint(ctx context.Context, endpointId int32) ApiPutUpdateIpsecEndpointRequest {
	return ApiPutUpdateIpsecEndpointRequest{
		ApiService: api,
		ctx: ctx,
		endpointId: endpointId,
	}
}

// Execute executes the request
//  @return m.IpsecRemoteEndpointDetail
func (api *IpsecApiService) PutUpdateIpsecEndpointExecute(r ApiPutUpdateIpsecEndpointRequest) (*m.IpsecRemoteEndpointDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.IpsecRemoteEndpointDetail
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "IpsecApiService.PutUpdateIpsecEndpoint")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipsec/endpoints/{endpoint_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"endpoint_id"+"}", url.PathEscape(parameterToString(r.endpointId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.endpointId < 1 {
		return localVarReturnValue, nil, reportError("endpointId must be greater than 1")
	}
	if r.updateIpsecEndpointRequest == nil {
		return localVarReturnValue, nil, reportError("updateIpsecEndpointRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateIpsecEndpointRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutUpdateIpsecEndpointTunnelRequest struct {
	ctx context.Context
	ApiService *IpsecApiService
	endpointId int32
	tunnelId int32
	updateIpsecTunnelRequest *m.UpdateIpsecTunnelRequest
}

func (r ApiPutUpdateIpsecEndpointTunnelRequest) UpdateIpsecTunnelRequest(updateIpsecTunnelRequest m.UpdateIpsecTunnelRequest) ApiPutUpdateIpsecEndpointTunnelRequest {
	r.updateIpsecTunnelRequest = &updateIpsecTunnelRequest
	return r
}

func (r ApiPutUpdateIpsecEndpointTunnelRequest) Execute() (*m.IpsecTunnelDetail, *http.Response, error) {
	return r.ApiService.PutUpdateIpsecEndpointTunnelExecute(r)
}

/*
PutUpdateIpsecEndpointTunnel Update IPsec endpoint tunnel

Edit IPsec endpoint tunnel configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointId ID for IPsec endpoint
 @param tunnelId ID for tunnel
 @return ApiPutUpdateIpsecEndpointTunnelRequest
*/
func (api *IpsecApiService) PutUpdateIpsecEndpointTunnel(ctx context.Context, endpointId int32, tunnelId int32) ApiPutUpdateIpsecEndpointTunnelRequest {
	return ApiPutUpdateIpsecEndpointTunnelRequest{
		ApiService: api,
		ctx: ctx,
		endpointId: endpointId,
		tunnelId: tunnelId,
	}
}

// Execute executes the request
//  @return m.IpsecTunnelDetail
func (api *IpsecApiService) PutUpdateIpsecEndpointTunnelExecute(r ApiPutUpdateIpsecEndpointTunnelRequest) (*m.IpsecTunnelDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.IpsecTunnelDetail
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "IpsecApiService.PutUpdateIpsecEndpointTunnel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipsec/endpoints/{endpoint_id}/tunnels/{tunnel_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"endpoint_id"+"}", url.PathEscape(parameterToString(r.endpointId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tunnel_id"+"}", url.PathEscape(parameterToString(r.tunnelId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.endpointId < 1 {
		return localVarReturnValue, nil, reportError("endpointId must be greater than 1")
	}
	if r.updateIpsecTunnelRequest == nil {
		return localVarReturnValue, nil, reportError("updateIpsecTunnelRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateIpsecTunnelRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutUpdateIpsecTrafficPairRequest struct {
	ctx context.Context
	ApiService *IpsecApiService
	endpointId int32
	pairId int32
	updateIpsecTrafficPairRequest *m.UpdateIpsecTrafficPairRequest
}

func (r ApiPutUpdateIpsecTrafficPairRequest) UpdateIpsecTrafficPairRequest(updateIpsecTrafficPairRequest m.UpdateIpsecTrafficPairRequest) ApiPutUpdateIpsecTrafficPairRequest {
	r.updateIpsecTrafficPairRequest = &updateIpsecTrafficPairRequest
	return r
}

func (r ApiPutUpdateIpsecTrafficPairRequest) Execute() (*m.IpsecTrafficPairResponse, *http.Response, error) {
	return r.ApiService.PutUpdateIpsecTrafficPairExecute(r)
}

/*
PutUpdateIpsecTrafficPair Update IPsec traffic pair

Edit IPsec endpoint traffic pair

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param endpointId ID for IPsec endpoint
 @param pairId ID for traffic pair
 @return ApiPutUpdateIpsecTrafficPairRequest
*/
func (api *IpsecApiService) PutUpdateIpsecTrafficPair(ctx context.Context, endpointId int32, pairId int32) ApiPutUpdateIpsecTrafficPairRequest {
	return ApiPutUpdateIpsecTrafficPairRequest{
		ApiService: api,
		ctx: ctx,
		endpointId: endpointId,
		pairId: pairId,
	}
}

// Execute executes the request
//  @return m.IpsecTrafficPairResponse
func (api *IpsecApiService) PutUpdateIpsecTrafficPairExecute(r ApiPutUpdateIpsecTrafficPairRequest) (*m.IpsecTrafficPairResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *m.IpsecTrafficPairResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "IpsecApiService.PutUpdateIpsecTrafficPair")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ipsec/endpoints/{endpoint_id}/traffic_pairs/{pair_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"endpoint_id"+"}", url.PathEscape(parameterToString(r.endpointId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pair_id"+"}", url.PathEscape(parameterToString(r.pairId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.endpointId < 1 {
		return localVarReturnValue, nil, reportError("endpointId must be greater than 1")
	}
	if r.updateIpsecTrafficPairRequest == nil {
		return localVarReturnValue, nil, reportError("updateIpsecTrafficPairRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateIpsecTrafficPairRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v m.ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
