/*
VNS3 Controller API

Cohesive networks VNS3 provides complete control of your network's addressing, routes, rules and edge enabling a secure, connected and reactive cloud network. 

API version: 6.0.0
Contact: support@cohesive.net
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package cohesivenet

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// ConfigurationApiService ConfigurationApi service
type ConfigurationApiService service

type ApiDeleteCustomVariableRequest struct {
	ctx context.Context
	ApiService *ConfigurationApiService
	name string
}

func (r ApiDeleteCustomVariableRequest) Execute() (*VariablesListResponse, *http.Response, error) {
	return r.ApiService.DeleteCustomVariableExecute(r)
}

/*
DeleteCustomVariable Delete custom variable from system

Delete custom variable

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of variable
 @return ApiDeleteCustomVariableRequest
*/
func (api *ConfigurationApiService) DeleteCustomVariable(ctx context.Context, name string) ApiDeleteCustomVariableRequest {
	return ApiDeleteCustomVariableRequest{
		ApiService: api,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return Object
func (api *ConfigurationApiService) DeleteCustomVariableExecute(r ApiDeleteCustomVariableRequest) (*VariablesListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VariablesListResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationApiService.DeleteCustomVariable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/variables/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}


type ApiGetVariableCollectionsRequest struct {
	ctx context.Context
	ApiService *ConfigurationApiService
	collections *string
}

// filter variables by collections (accepts csv A,B,C)
func (r ApiGetVariableCollectionsRequest) Collections(collections string) ApiGetVariableCollectionsRequest {
	r.collections = &collections
	return r
}

func (r ApiGetVariableCollectionsRequest) Execute() (*VariableCollectionsListResponse, *http.Response, error) {
	return r.ApiService.GetVariableCollectionsExecute(r)
}

/*
GetVariableCollections Get system variable collection details

Get system variable collections

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetVariableCollectionsRequest
*/
func (api *ConfigurationApiService) GetVariableCollections(ctx context.Context) ApiGetVariableCollectionsRequest {
	return ApiGetVariableCollectionsRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VariableCollectionsListResponse
func (api *ConfigurationApiService) GetVariableCollectionsExecute(r ApiGetVariableCollectionsRequest) (*VariableCollectionsListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VariableCollectionsListResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationApiService.GetVariableCollections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/variable-collections"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.collections != nil {
		localVarQueryParams.Add("collections", parameterToString(*r.collections, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVariablesRequest struct {
	ctx context.Context
	ApiService *ConfigurationApiService
}

func (r ApiGetVariablesRequest) Execute() (*VariablesListResponse, *http.Response, error) {
	return r.ApiService.GetVariablesExecute(r)
}

/*
GetVariables Get system variables grouped by collections

Get system variables

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetVariablesRequest
*/
func (api *ConfigurationApiService) GetVariables(ctx context.Context) ApiGetVariablesRequest {
	return ApiGetVariablesRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VariablesListResponse
func (api *ConfigurationApiService) GetVariablesExecute(r ApiGetVariablesRequest) (*VariablesListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VariablesListResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationApiService.GetVariables")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/variables"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCreateCustomVariableRequest struct {
	ctx context.Context
	ApiService *ConfigurationApiService
	createCustomVariableRequest *CreateCustomVariableRequest
}

func (r ApiPostCreateCustomVariableRequest) CreateCustomVariableRequest(createCustomVariableRequest CreateCustomVariableRequest) ApiPostCreateCustomVariableRequest {
	r.createCustomVariableRequest = &createCustomVariableRequest
	return r
}

func (r ApiPostCreateCustomVariableRequest) Execute() (*VariablesListResponse, *http.Response, error) {
	return r.ApiService.PostCreateCustomVariableExecute(r)
}

/*
PostCreateCustomVariable create custom variable for system

create custom variable

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCreateCustomVariableRequest
*/
func (api *ConfigurationApiService) PostCreateCustomVariable(ctx context.Context) ApiPostCreateCustomVariableRequest {
	return ApiPostCreateCustomVariableRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Object
func (api *ConfigurationApiService) PostCreateCustomVariableExecute(r ApiPostCreateCustomVariableRequest) (*VariablesListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VariablesListResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationApiService.PostCreateCustomVariable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/variables"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createCustomVariableRequest == nil {
		return localVarReturnValue, nil, reportError("createCustomVariableRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createCustomVariableRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConfigRequest struct {
	ctx context.Context
	ApiService *ConfigurationApiService
}

func (r ApiGetConfigRequest) Execute() (*ConfigDetail, *http.Response, error) {
	return r.ApiService.GetConfigExecute(r)
}

/*
GetConfig Get configuration details

Describe Runtime Configuration for VNS3 Controller

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetConfigRequest
*/
func (api *ConfigurationApiService) GetConfig(ctx context.Context) ApiGetConfigRequest {
	return ApiGetConfigRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConfigDetail
func (api *ConfigurationApiService) GetConfigExecute(r ApiGetConfigRequest) (*ConfigDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConfigDetail
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationApiService.GetConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetKeysetRequest struct {
	ctx context.Context
	ApiService *ConfigurationApiService
}

func (r ApiGetKeysetRequest) Execute() (*KeysetDetail, *http.Response, error) {
	return r.ApiService.GetKeysetExecute(r)
}

/*
GetKeyset Get topology keyset

Returns keyset details. The keyset is a set of cryptographic credentials  used for encrypting all data on the overlay network.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetKeysetRequest
*/
func (api *ConfigurationApiService) GetKeyset(ctx context.Context) ApiGetKeysetRequest {
	return ApiGetKeysetRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KeysetDetail
func (api *ConfigurationApiService) GetKeysetExecute(r ApiGetKeysetRequest) (*KeysetDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KeysetDetail
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationApiService.GetKeyset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/keyset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLicenseRequest struct {
	ctx context.Context
	ApiService *ConfigurationApiService
}

func (r ApiGetLicenseRequest) Execute() (*LicenseDetail, *http.Response, error) {
	return r.ApiService.GetLicenseExecute(r)
}

/*
GetLicense Get license details

Get license details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLicenseRequest
*/
func (api *ConfigurationApiService) GetLicense(ctx context.Context) ApiGetLicenseRequest {
	return ApiGetLicenseRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LicenseDetail
func (api *ConfigurationApiService) GetLicenseExecute(r ApiGetLicenseRequest) (*LicenseDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LicenseDetail
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationApiService.GetLicense")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/license"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMsConfigRequest struct {
	ctx context.Context
	ApiService *ConfigurationApiService
	ip *string
}

// name of resource
func (r ApiGetMsConfigRequest) Ip(ip string) ApiGetMsConfigRequest {
	r.ip = &ip
	return r
}

func (r ApiGetMsConfigRequest) Execute() (*AlertDetailResponse, *http.Response, error) {
	return r.ApiService.GetMsConfigExecute(r)
}

/*
GetMsConfig Get MS configuration

Get MS configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMsConfigRequest
*/
func (api *ConfigurationApiService) GetMsConfig(ctx context.Context) ApiGetMsConfigRequest {
	return ApiGetMsConfigRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AlertDetailResponse
func (api *ConfigurationApiService) GetMsConfigExecute(r ApiGetMsConfigRequest) (*AlertDetailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertDetailResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationApiService.GetMsConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.ip != nil {
		localVarQueryParams.Add("ip", parameterToString(*r.ip, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSSLCertsRequest struct {
	ctx context.Context
	ApiService *ConfigurationApiService
}

func (r ApiGetSSLCertsRequest) Execute() (*SSLCertsListResponse, *http.Response, error) {
	return r.ApiService.GetSSLCertsExecute(r)
}

/*
GetSSLCerts Get SSL Certificates

Get SSL Certificates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSSLCertsRequest
*/
func (api *ConfigurationApiService) GetSSLCerts(ctx context.Context) ApiGetSSLCertsRequest {
	return ApiGetSSLCertsRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SSLCertsListResponse
func (api *ConfigurationApiService) GetSSLCertsExecute(r ApiGetSSLCertsRequest) (*SSLCertsListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SSLCertsListResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationApiService.GetSSLCerts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/ssl"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}


/*
TODO SSL Endpoints
*/

// type ApiGetSslInstallStatusRequest struct {
// 	ctx context.Context
// 	ApiService *ConfigurationApiService
// 	uuid string
// }

// func (r ApiGetSslInstallStatusRequest) Execute() (*Object, *http.Response, error) {
// 	return r.ApiService.GetSslInstallStatusExecute(r)
// }

// /*
// GetSslInstallStatus Get SSL installation status

// Get status for ssl installation task

//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @param uuid uuid of resource
//  @return ApiGetSslInstallStatusRequest
// */
// func (api *ConfigurationApiService) GetSslInstallStatus(ctx context.Context, uuid string) ApiGetSslInstallStatusRequest {
// 	return ApiGetSslInstallStatusRequest{
// 		ApiService: api,
// 		ctx: ctx,
// 		uuid: uuid,
// 	}
// }

// // Execute executes the request
// //  @return Object
// func (api *ConfigurationApiService) GetSslInstallStatusExecute(r ApiGetSslInstallStatusRequest) (*Object, *http.Response, error) {
// 	var (
// 		localVarHTTPMethod   = http.MethodGet
// 		localVarPostBody     interface{}
// 		formFiles            []formFile
// 		localVarReturnValue  *Object
// 	)

// 	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationApiService.GetSslInstallStatus")
// 	if err != nil {
// 		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
// 	}

// 	localVarPath := localBasePath + "/system/ssl/install/{uuid}"
// 	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterToString(r.uuid, "")), -1)

// 	localVarHeaderParams := make(map[string]string)
// 	localVarQueryParams := url.Values{}
// 	localVarFormParams := url.Values{}

// 	// to determine the Content-Type header
// 	localVarHTTPContentTypes := []string{}

// 	// set Content-Type header
// 	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
// 	if localVarHTTPContentType != "" {
// 		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
// 	}

// 	// to determine the Accept header
// 	localVarHTTPHeaderAccepts := []string{"application/json"}

// 	// set Accept header
// 	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
// 	if localVarHTTPHeaderAccept != "" {
// 		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
// 	}
// 	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
// 	if err != nil {
// 		return localVarReturnValue, nil, err
// 	}

// 	localVarHTTPResponse, err := api.client.callAPI(req)
// 	if err != nil || localVarHTTPResponse == nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
// 	localVarHTTPResponse.Body.Close()
// 	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
// 	if err != nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	if localVarHTTPResponse.StatusCode >= 300 {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: localVarHTTPResponse.Status,
// 		}
// 		if localVarHTTPResponse.StatusCode == 404 {
// 			var v ErrorResponse
// 			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 			newErr.model = v
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 	if err != nil {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: err.Error(),
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	return localVarReturnValue, localVarHTTPResponse, nil
// }


// type ApiPutInstallSslKeypairRequest struct {
// 	ctx context.Context
// 	ApiService *ConfigurationApiService
// }

// func (r ApiPutInstallSslKeypairRequest) Execute() (*ServerSSLDetailResponse, *http.Response, error) {
// 	return r.ApiService.PutInstallSslKeypairExecute(r)
// }

// /*
// PutInstallSslKeypair Install SSL cert and key pair

// Install SSL cert and key pair

//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @return ApiPutInstallSslKeypairRequest
// */
// func (api *ConfigurationApiService) PutInstallSslKeypair(ctx context.Context) ApiPutInstallSslKeypairRequest {
// 	return ApiPutInstallSslKeypairRequest{
// 		ApiService: api,
// 		ctx: ctx,
// 	}
// }

// // Execute executes the request
// //  @return ServerSSLDetailResponse
// func (api *ConfigurationApiService) PutInstallSslKeypairExecute(r ApiPutInstallSslKeypairRequest) (*ServerSSLDetailResponse, *http.Response, error) {
// 	var (
// 		localVarHTTPMethod   = http.MethodPut
// 		localVarPostBody     interface{}
// 		formFiles            []formFile
// 		localVarReturnValue  *ServerSSLDetailResponse
// 	)

// 	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationApiService.PutInstallSslKeypair")
// 	if err != nil {
// 		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
// 	}

// 	localVarPath := localBasePath + "/system/ssl/install"

// 	localVarHeaderParams := make(map[string]string)
// 	localVarQueryParams := url.Values{}
// 	localVarFormParams := url.Values{}

// 	// to determine the Content-Type header
// 	localVarHTTPContentTypes := []string{}

// 	// set Content-Type header
// 	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
// 	if localVarHTTPContentType != "" {
// 		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
// 	}

// 	// to determine the Accept header
// 	localVarHTTPHeaderAccepts := []string{"application/json"}

// 	// set Accept header
// 	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
// 	if localVarHTTPHeaderAccept != "" {
// 		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
// 	}
// 	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
// 	if err != nil {
// 		return localVarReturnValue, nil, err
// 	}

// 	localVarHTTPResponse, err := api.client.callAPI(req)
// 	if err != nil || localVarHTTPResponse == nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
// 	localVarHTTPResponse.Body.Close()
// 	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
// 	if err != nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	if localVarHTTPResponse.StatusCode >= 300 {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: localVarHTTPResponse.Status,
// 		}
// 		if localVarHTTPResponse.StatusCode == 400 {
// 			var v ErrorResponse
// 			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 			newErr.model = v
// 			return localVarReturnValue, localVarHTTPResponse, newErr
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 	if err != nil {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: err.Error(),
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	return localVarReturnValue, localVarHTTPResponse, nil
// }


/*
TODO MS config Endpoints
*/


// type ApiPostSendTestMsAlertRequest struct {
// 	ctx context.Context
// 	ApiService *ConfigurationApiService
// }

// func (r ApiPostSendTestMsAlertRequest) Execute() (*SimpleBooleanResponse, *http.Response, error) {
// 	return r.ApiService.PostSendTestMsAlertExecute(r)
// }

// /*
// PostSendTestMsAlert Send test VNS3:ms alert

// Send test alert to VNS3:ms

//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @return ApiPostSendTestMsAlertRequest
// */
// func (api *ConfigurationApiService) PostSendTestMsAlert(ctx context.Context) ApiPostSendTestMsAlertRequest {
// 	return ApiPostSendTestMsAlertRequest{
// 		ApiService: api,
// 		ctx: ctx,
// 	}
// }

// // Execute executes the request
// //  @return SimpleBooleanResponse
// func (api *ConfigurationApiService) PostSendTestMsAlertExecute(r ApiPostSendTestMsAlertRequest) (*SimpleBooleanResponse, *http.Response, error) {
// 	var (
// 		localVarHTTPMethod   = http.MethodPost
// 		localVarPostBody     interface{}
// 		formFiles            []formFile
// 		localVarReturnValue  *SimpleBooleanResponse
// 	)

// 	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationApiService.PostSendTestMsAlert")
// 	if err != nil {
// 		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
// 	}

// 	localVarPath := localBasePath + "/ms/alert/test"

// 	localVarHeaderParams := make(map[string]string)
// 	localVarQueryParams := url.Values{}
// 	localVarFormParams := url.Values{}

// 	// to determine the Content-Type header
// 	localVarHTTPContentTypes := []string{}

// 	// set Content-Type header
// 	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
// 	if localVarHTTPContentType != "" {
// 		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
// 	}

// 	// to determine the Accept header
// 	localVarHTTPHeaderAccepts := []string{"application/json"}

// 	// set Accept header
// 	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
// 	if localVarHTTPHeaderAccept != "" {
// 		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
// 	}
// 	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
// 	if err != nil {
// 		return localVarReturnValue, nil, err
// 	}

// 	localVarHTTPResponse, err := api.client.callAPI(req)
// 	if err != nil || localVarHTTPResponse == nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
// 	localVarHTTPResponse.Body.Close()
// 	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
// 	if err != nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	if localVarHTTPResponse.StatusCode >= 300 {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: localVarHTTPResponse.Status,
// 		}
// 		if localVarHTTPResponse.StatusCode == 400 {
// 			var v ErrorResponse
// 			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 			newErr.model = v
// 			return localVarReturnValue, localVarHTTPResponse, newErr
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 	if err != nil {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: err.Error(),
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	return localVarReturnValue, localVarHTTPResponse, nil
// }

// type ApiPostSetMsConfigRequest struct {
// 	ctx context.Context
// 	ApiService *ConfigurationApiService
// 	msConfigRequest *MSConfigRequest
// }

// func (r ApiPostSetMsConfigRequest) MSConfigRequest(msConfigRequest MSConfigRequest) ApiPostSetMsConfigRequest {
// 	r.msConfigRequest = &msConfigRequest
// 	return r
// }

// func (r ApiPostSetMsConfigRequest) Execute() (*MSConfig, *http.Response, error) {
// 	return r.ApiService.PostSetMsConfigExecute(r)
// }

// /*
// PostSetMsConfig Set MS for controller

// Set VNS3 Management System endpoint

//  @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
//  @return ApiPostSetMsConfigRequest
// */
// func (api *ConfigurationApiService) PostSetMsConfig(ctx context.Context) ApiPostSetMsConfigRequest {
// 	return ApiPostSetMsConfigRequest{
// 		ApiService: api,
// 		ctx: ctx,
// 	}
// }

// // Execute executes the request
// //  @return MSConfig
// func (api *ConfigurationApiService) PostSetMsConfigExecute(r ApiPostSetMsConfigRequest) (*MSConfig, *http.Response, error) {
// 	var (
// 		localVarHTTPMethod   = http.MethodPost
// 		localVarPostBody     interface{}
// 		formFiles            []formFile
// 		localVarReturnValue  *MSConfig
// 	)

// 	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationApiService.PostSetMsConfig")
// 	if err != nil {
// 		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
// 	}

// 	localVarPath := localBasePath + "/ms"

// 	localVarHeaderParams := make(map[string]string)
// 	localVarQueryParams := url.Values{}
// 	localVarFormParams := url.Values{}
// 	if r.msConfigRequest == nil {
// 		return localVarReturnValue, nil, reportError("msConfigRequest is required and must be specified")
// 	}

// 	// to determine the Content-Type header
// 	localVarHTTPContentTypes := []string{"application/json"}

// 	// set Content-Type header
// 	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
// 	if localVarHTTPContentType != "" {
// 		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
// 	}

// 	// to determine the Accept header
// 	localVarHTTPHeaderAccepts := []string{"application/json"}

// 	// set Accept header
// 	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
// 	if localVarHTTPHeaderAccept != "" {
// 		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
// 	}
// 	// body params
// 	localVarPostBody = r.msConfigRequest
// 	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
// 	if err != nil {
// 		return localVarReturnValue, nil, err
// 	}

// 	localVarHTTPResponse, err := api.client.callAPI(req)
// 	if err != nil || localVarHTTPResponse == nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
// 	localVarHTTPResponse.Body.Close()
// 	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
// 	if err != nil {
// 		return localVarReturnValue, localVarHTTPResponse, err
// 	}

// 	if localVarHTTPResponse.StatusCode >= 300 {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: localVarHTTPResponse.Status,
// 		}
// 		if localVarHTTPResponse.StatusCode == 400 {
// 			var v ErrorResponse
// 			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 			if err != nil {
// 				newErr.error = err.Error()
// 				return localVarReturnValue, localVarHTTPResponse, newErr
// 			}
// 			newErr.model = v
// 			return localVarReturnValue, localVarHTTPResponse, newErr
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
// 	if err != nil {
// 		newErr := &GenericOpenAPIError{
// 			body:  localVarBody,
// 			error: err.Error(),
// 		}
// 		return localVarReturnValue, localVarHTTPResponse, newErr
// 	}

// 	return localVarReturnValue, localVarHTTPResponse, nil
// }

type ApiPutConfigRequest struct {
	ctx context.Context
	ApiService *ConfigurationApiService
	updateConfigRequest *UpdateConfigRequest
}

func (r ApiPutConfigRequest) UpdateConfigRequest(updateConfigRequest UpdateConfigRequest) ApiPutConfigRequest {
	r.updateConfigRequest = &updateConfigRequest
	return r
}

func (r ApiPutConfigRequest) Execute() (*ConfigDetail, *http.Response, error) {
	return r.ApiService.PutConfigExecute(r)
}

/*
PutConfig Update configuration

Provides general information about the manager's topology, license state and  checksums and allows you to set the topology name.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutConfigRequest
*/
func (api *ConfigurationApiService) PutConfig(ctx context.Context) ApiPutConfigRequest {
	return ApiPutConfigRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConfigDetail
func (api *ConfigurationApiService) PutConfigExecute(r ApiPutConfigRequest) (*ConfigDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConfigDetail
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationApiService.PutConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateConfigRequest == nil {
		return localVarReturnValue, nil, reportError("updateConfigRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateConfigRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutKeysetRequest struct {
	ctx context.Context
	ApiService *ConfigurationApiService
	updateKeysetRequest *UpdateKeysetRequest
}

func (r ApiPutKeysetRequest) UpdateKeysetRequest(updateKeysetRequest UpdateKeysetRequest) ApiPutKeysetRequest {
	r.updateKeysetRequest = &updateKeysetRequest
	return r
}

func (r ApiPutKeysetRequest) Execute() (*KeysetDetail, *http.Response, error) {
	return r.ApiService.PutKeysetExecute(r)
}

/*
PutKeyset Generate keyset

Generate keyset The keyset is a set of cryptographic credentials used for encrypting all data on the overlay network. Keyset generation happens in background. Poll on GET /keyset in_progress value for keyset status.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutKeysetRequest
*/
func (api *ConfigurationApiService) PutKeyset(ctx context.Context) ApiPutKeysetRequest {
	return ApiPutKeysetRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KeysetDetail
func (api *ConfigurationApiService) PutKeysetExecute(r ApiPutKeysetRequest) (*KeysetDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KeysetDetail
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationApiService.PutKeyset")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/keyset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateKeysetRequest == nil {
		return localVarReturnValue, nil, reportError("updateKeysetRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateKeysetRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutLicenseUpgradeRequest struct {
	ctx context.Context
	ApiService *ConfigurationApiService
	body **os.File
}

// License file
func (r ApiPutLicenseUpgradeRequest) Body(body *os.File) ApiPutLicenseUpgradeRequest {
	r.body = &body
	return r
}

func (r ApiPutLicenseUpgradeRequest) Execute() (*UpgradeLicenseResponse, *http.Response, error) {
	return r.ApiService.PutLicenseUpgradeExecute(r)
}

/*
PutLicenseUpgrade Upgrade license

Upload new license to controller

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutLicenseUpgradeRequest
*/
func (api *ConfigurationApiService) PutLicenseUpgrade(ctx context.Context) ApiPutLicenseUpgradeRequest {
	return ApiPutLicenseUpgradeRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpgradeLicenseResponse
func (api *ConfigurationApiService) PutLicenseUpgradeExecute(r ApiPutLicenseUpgradeRequest) (*UpgradeLicenseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpgradeLicenseResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationApiService.PutLicenseUpgrade")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/license/upgrade"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutSetLicenseParametersRequest struct {
	ctx context.Context
	ApiService *ConfigurationApiService
	putLicenseParametersRequest *SetLicenseParametersRequest
}

func (r ApiPutSetLicenseParametersRequest) PutLicenseParametersRequest(putLicenseParametersRequest SetLicenseParametersRequest) ApiPutSetLicenseParametersRequest {
	r.putLicenseParametersRequest = &putLicenseParametersRequest
	return r
}

func (r ApiPutSetLicenseParametersRequest) Execute() (*LicenseParametersDetail, *http.Response, error) {
	return r.ApiService.PutSetLicenseParametersExecute(r)
}

/*
PutSetLicenseParameters Set license parameters

Set and accept license parameters. Triggers reboot. Irreversible operation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutSetLicenseParametersRequest
*/
func (api *ConfigurationApiService) PutSetLicenseParameters(ctx context.Context) ApiPutSetLicenseParametersRequest {
	return ApiPutSetLicenseParametersRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LicenseParametersDetail
func (api *ConfigurationApiService) PutSetLicenseParametersExecute(r ApiPutSetLicenseParametersRequest) (*LicenseParametersDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LicenseParametersDetail
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationApiService.PutSetLicenseParameters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/license/parameters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.putLicenseParametersRequest == nil {
		return localVarReturnValue, nil, reportError("putLicenseParametersRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.putLicenseParametersRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutUpdateAdminUiRequest struct {
	ctx context.Context
	ApiService *ConfigurationApiService
	updateAdminUISettingsRequest *UpdateAdminUISettingsRequest
}

func (r ApiPutUpdateAdminUiRequest) UpdateAdminUISettingsRequest(updateAdminUISettingsRequest UpdateAdminUISettingsRequest) ApiPutUpdateAdminUiRequest {
	r.updateAdminUISettingsRequest = &updateAdminUISettingsRequest
	return r
}

func (r ApiPutUpdateAdminUiRequest) Execute() (*AdminUISettingsResponse, *http.Response, error) {
	return r.ApiService.PutUpdateAdminUiExecute(r)
}

/*
PutUpdateAdminUi Update admin UI settings

Update Admin UI settings. Enable/Disable and set credentials.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutUpdateAdminUiRequest
*/
func (api *ConfigurationApiService) PutUpdateAdminUi(ctx context.Context) ApiPutUpdateAdminUiRequest {
	return ApiPutUpdateAdminUiRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AdminUISettingsResponse
func (api *ConfigurationApiService) PutUpdateAdminUiExecute(r ApiPutUpdateAdminUiRequest) (*AdminUISettingsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdminUISettingsResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationApiService.PutUpdateAdminUi")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin_ui"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateAdminUISettingsRequest == nil {
		return localVarReturnValue, nil, reportError("updateAdminUISettingsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateAdminUISettingsRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutUpdateApiPasswordRequest struct {
	ctx context.Context
	ApiService *ConfigurationApiService
	updatePasswordRequest *UpdatePasswordRequest
}

func (r ApiPutUpdateApiPasswordRequest) UpdatePasswordRequest(updatePasswordRequest UpdatePasswordRequest) ApiPutUpdateApiPasswordRequest {
	r.updatePasswordRequest = &updatePasswordRequest
	return r
}

func (r ApiPutUpdateApiPasswordRequest) Execute() (*PasswordResetResponse, *http.Response, error) {
	return r.ApiService.PutUpdateApiPasswordExecute(r)
}

/*
PutUpdateApiPassword Update API password

Allows you to change the API password/secret key.  To change the Web UI password (or username) use PUT admin_ui.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutUpdateApiPasswordRequest
*/
func (api *ConfigurationApiService) PutUpdateApiPassword(ctx context.Context) ApiPutUpdateApiPasswordRequest {
	return ApiPutUpdateApiPasswordRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PasswordResetResponse
func (api *ConfigurationApiService) PutUpdateApiPasswordExecute(r ApiPutUpdateApiPasswordRequest) (*PasswordResetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PasswordResetResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationApiService.PutUpdateApiPassword")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api_password"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updatePasswordRequest == nil {
		return localVarReturnValue, nil, reportError("updatePasswordRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updatePasswordRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutUpdateCustomVariableRequest struct {
	ctx context.Context
	ApiService *ConfigurationApiService
	name string
	updateCustomVariableRequest *UpdateCustomVariableRequest
}

func (r ApiPutUpdateCustomVariableRequest) UpdateCustomVariableRequest(updateCustomVariableRequest UpdateCustomVariableRequest) ApiPutUpdateCustomVariableRequest {
	r.updateCustomVariableRequest = &updateCustomVariableRequest
	return r
}

func (r ApiPutUpdateCustomVariableRequest) Execute() (*VariableDetailResponse, *http.Response, error) {
	return r.ApiService.PutUpdateCustomVariableExecute(r)
}

/*
PutUpdateCustomVariable Update custom variable value

Update custom variable

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name name of variable
 @return ApiPutUpdateCustomVariableRequest
*/
func (api *ConfigurationApiService) PutUpdateCustomVariable(ctx context.Context, name string) ApiPutUpdateCustomVariableRequest {
	return ApiPutUpdateCustomVariableRequest{
		ApiService: api,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return VariableDetailResponse
func (api *ConfigurationApiService) PutUpdateCustomVariableExecute(r ApiPutUpdateCustomVariableRequest) (*VariableDetailResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VariableDetailResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationApiService.PutUpdateCustomVariable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/variables/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterToString(r.name, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateCustomVariableRequest == nil {
		return localVarReturnValue, nil, reportError("updateCustomVariableRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateCustomVariableRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutUploadSslKeypairRequest struct {
	ctx context.Context
	ApiService *ConfigurationApiService
	updateServerSSLRequest *UpdateServerSSLRequest
}

func (r ApiPutUploadSslKeypairRequest) UpdateServerSSLRequest(updateServerSSLRequest UpdateServerSSLRequest) ApiPutUploadSslKeypairRequest {
	r.updateServerSSLRequest = &updateServerSSLRequest
	return r
}

func (r ApiPutUploadSslKeypairRequest) Execute() (*SimpleStringResponse, *http.Response, error) {
	return r.ApiService.PutUploadSslKeypairExecute(r)
}

/*
PutUploadSslKeypair Upload new SSL cert and key pair

Upload new SSL cert and key pair

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutUploadSslKeypairRequest
*/
func (api *ConfigurationApiService) PutUploadSslKeypair(ctx context.Context) ApiPutUploadSslKeypairRequest {
	return ApiPutUploadSslKeypairRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Object
func (api *ConfigurationApiService) PutUploadSslKeypairExecute(r ApiPutUploadSslKeypairRequest) (*SimpleStringResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SimpleStringResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationApiService.PutUploadSslKeypair")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/system/ssl/keypair"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateServerSSLRequest == nil {
		return localVarReturnValue, nil, reportError("updateServerSSLRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateServerSSLRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateMsConfigRequest struct {
	ctx context.Context
	ApiService *ConfigurationApiService
	updateMSRequest *UpdateMSRequest
}

func (r ApiUpdateMsConfigRequest) UpdateMSRequest(updateMSRequest UpdateMSRequest) ApiUpdateMsConfigRequest {
	r.updateMSRequest = &updateMSRequest
	return r
}

func (r ApiUpdateMsConfigRequest) Execute() (*MSConfigResponse, *http.Response, error) {
	return r.ApiService.UpdateMsConfigExecute(r)
}

/*
UpdateMsConfig Update MS config for controller

Update VNS3 Management System integration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateMsConfigRequest
*/
func (api *ConfigurationApiService) UpdateMsConfig(ctx context.Context) ApiUpdateMsConfigRequest {
	return ApiUpdateMsConfigRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MSConfigResponse
func (api *ConfigurationApiService) UpdateMsConfigExecute(r ApiUpdateMsConfigRequest) (*MSConfigResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MSConfigResponse
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationApiService.UpdateMsConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateMSRequest == nil {
		return localVarReturnValue, nil, reportError("updateMSRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateMSRequest
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUploadLicenseRequest struct {
	ctx context.Context
	ApiService *ConfigurationApiService
	body **os.File
}

// License file
func (r ApiUploadLicenseRequest) Body(body *os.File) ApiUploadLicenseRequest {
	r.body = &body
	return r
}

func (r ApiUploadLicenseRequest) Execute() (*InitLicenseDetail, *http.Response, error) {
	return r.ApiService.UploadLicenseExecute(r)
}

/*
UploadLicense Upload license

License a VNS3 Controller to be a part of a specific topology. Must not be licensed already.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUploadLicenseRequest
*/
func (api *ConfigurationApiService) UploadLicense(ctx context.Context) ApiUploadLicenseRequest {
	return ApiUploadLicenseRequest{
		ApiService: api,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InitLicenseDetail
func (api *ConfigurationApiService) UploadLicenseExecute(r ApiUploadLicenseRequest) (*InitLicenseDetail, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InitLicenseDetail
	)

	localBasePath, err := api.client.cfg.ServerURLWithContext(r.ctx, "ConfigurationApiService.UploadLicense")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/license"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := api.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := api.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponse
			err = api.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = api.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
